
AVRASM ver. 2.1.12  core\bldc.asm Wed Sep 28 15:06:41 2011

[builtin](2): Including file 'C:\Program Files (x86)\AvrAssembler2\AppNotes\m8def.inc'
[builtin](3): Including file 'core\..\input\pwm_rc_200.inc'
[builtin](4): Including file 'core\..\hw\Qynx20A.inc'
core\..\hw\Qynx20A.inc(1): Including file 'core\common.inc'
core\bldc.asm(22): Including file 'core\ppm_light.inc'
                 
                 ;**** **** **** **** ****
                 
                 ;***** Created: 2007-02-28 07:32 ******* Source: ATmega8.xml *************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m8def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega8
                 ;* Date              : 2007-02-28
                 ;* Version           : 2.24
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega8
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M8DEF_INC_
                 #define _M8DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega8
                 #pragma AVRPART ADMIN PART_NAME ATmega8
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x93
                 .equ	SIGNATURE_002	= 0x07
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	GICR	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCR	= 0x37
                 .equ	TWCR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUCSR	= 0x34
                 .equ	TCCR0	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	SFIOR	= 0x30
                 .equ	TCCR1A	= 0x2f
                 .equ	TCCR1B	= 0x2e
                 .equ	TCNT1L	= 0x2c
                 .equ	TCNT1H	= 0x2d
                 .equ	OCR1AL	= 0x2a
                 .equ	OCR1AH	= 0x2b
                 .equ	OCR1BL	= 0x28
                 .equ	OCR1BH	= 0x29
                 .equ	ICR1L	= 0x26
                 .equ	ICR1H	= 0x27
                 .equ	TCCR2	= 0x25
                 .equ	TCNT2	= 0x24
                 .equ	OCR2	= 0x23
                 .equ	ASSR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	UBRRH	= 0x20
                 .equ	UCSRC	= 0x20
                 .equ	EEARL	= 0x1e
                 .equ	EEARH	= 0x1f
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PORTC	= 0x15
                 .equ	DDRC	= 0x14
                 .equ	PINC	= 0x13
                 .equ	PORTD	= 0x12
                 .equ	DDRD	= 0x11
                 .equ	PIND	= 0x10
                 .equ	SPDR	= 0x0f
                 .equ	SPSR	= 0x0e
                 .equ	SPCR	= 0x0d
                 .equ	UDR	= 0x0c
                 .equ	UCSRA	= 0x0b
                 .equ	UCSRB	= 0x0a
                 .equ	UBRRL	= 0x09
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCL	= 0x04
                 .equ	ADCH	= 0x05
                 .equ	TWDR	= 0x03
                 .equ	TWAR	= 0x02
                 .equ	TWSR	= 0x01
                 .equ	TWBR	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; SFIOR - Special Function IO Register
                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; GICR - General Interrupt Control Register
                 .equ	GIMSK	= GICR	; For compatibility
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                 
                 ; GIFR - General Interrupt Flag Register
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 .equ	INTF1	= 7	; External Interrupt Flag 1
                 
                 ; MCUCR - MCU Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 
                 ; TCCR0 - Timer/Counter0 Control Register
                 .equ	CS00	= 0	; Clock Select0 bit 0
                 .equ	CS01	= 1	; Clock Select0 bit 1
                 .equ	CS02	= 2	; Clock Select0 bit 2
                 
                 ; TCNT0 - Timer Counter 0
                 .equ	TCNT00	= 0	; Timer Counter 0 bit 0
                 .equ	TCNT01	= 1	; Timer Counter 0 bit 1
                 .equ	TCNT02	= 2	; Timer Counter 0 bit 2
                 .equ	TCNT03	= 3	; Timer Counter 0 bit 3
                 .equ	TCNT04	= 4	; Timer Counter 0 bit 4
                 .equ	TCNT05	= 5	; Timer Counter 0 bit 5
                 .equ	TCNT06	= 6	; Timer Counter 0 bit 6
                 .equ	TCNT07	= 7	; Timer Counter 0 bit 7
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	FOC1B	= 2	; Force Output Compare 1B
                 .equ	FOC1A	= 3	; Force Output Compare 1A
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	CTC1	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                 .equ	OCF2	= 7	; Output Compare Flag 2
                 
                 ; TCCR2 - Timer/Counter2 Control Register
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM21	= 3	; Waveform Generation Mode
                 .equ	CTC2	= WGM21	; For compatibility
                 .equ	COM20	= 4	; Compare Output Mode bit 0
                 .equ	COM21	= 5	; Compare Output Mode bit 1
                 .equ	WGM20	= 6	; Waveform Genration Mode
                 .equ	PWM2	= WGM20	; For compatibility
                 .equ	FOC2	= 7	; Force Output Compare
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2 - Timer/Counter2 Output Compare Register
                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                 
                 
                 ; ***** USART ************************
                 ; UDR - USART I/O Data Register
                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSRA - USART Control and Status Register A
                 .equ	USR	= UCSRA	; For compatibility
                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                 .equ	U2X	= 1	; Double the USART transmission speed
                 .equ	UPE	= 2	; Parity Error
                 .equ	PE	= UPE	; For compatibility
                 .equ	DOR	= 3	; Data overRun
                 .equ	FE	= 4	; Framing Error
                 .equ	UDRE	= 5	; USART Data Register Empty
                 .equ	TXC	= 6	; USART Transmitt Complete
                 .equ	RXC	= 7	; USART Receive Complete
                 
                 ; UCSRB - USART Control and Status Register B
                 .equ	UCR	= UCSRB	; For compatibility
                 .equ	TXB8	= 0	; Transmit Data Bit 8
                 .equ	RXB8	= 1	; Receive Data Bit 8
                 .equ	UCSZ2	= 2	; Character Size
                 .equ	CHR9	= UCSZ2	; For compatibility
                 .equ	TXEN	= 3	; Transmitter Enable
                 .equ	RXEN	= 4	; Receiver Enable
                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSRC - USART Control and Status Register C
                 .equ	UCPOL	= 0	; Clock Polarity
                 .equ	UCSZ0	= 1	; Character Size
                 .equ	UCSZ1	= 2	; Character Size
                 .equ	USBS	= 3	; Stop Bit Select
                 .equ	UPM0	= 4	; Parity Mode Bit 0
                 .equ	UPM1	= 5	; Parity Mode Bit 1
                 .equ	UMSEL	= 6	; USART Mode Select
                 .equ	URSEL	= 7	; Register Select
                 
                 .equ	UBRRHI	= UBRRH	; For compatibility
                 
                 ; ***** TWI **************************
                 ; TWBR - TWI Bit Rate register
                 .equ	I2BR	= TWBR	; For compatibility
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	I2CR	= TWCR	; For compatibility
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	I2IE	= TWIE	; For compatibility
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	I2EN	= TWEN	; For compatibility
                 .equ	ENI2C	= TWEN	; For compatibility
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	I2WC	= TWWC	; For compatibility
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	I2STO	= TWSTO	; For compatibility
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	I2STA	= TWSTA	; For compatibility
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	I2EA	= TWEA	; For compatibility
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 .equ	I2INT	= TWINT	; For compatibility
                 
                 ; TWSR - TWI Status Register
                 .equ	I2SR	= TWSR	; For compatibility
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWS0	= TWPS0	; For compatibility
                 .equ	I2GCE	= TWPS0	; For compatibility
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS1	= TWPS1	; For compatibility
                 .equ	TWS3	= 3	; TWI Status
                 .equ	I2S3	= TWS3	; For compatibility
                 .equ	TWS4	= 4	; TWI Status
                 .equ	I2S4	= TWS4	; For compatibility
                 .equ	TWS5	= 5	; TWI Status
                 .equ	I2S5	= TWS5	; For compatibility
                 .equ	TWS6	= 6	; TWI Status
                 .equ	I2S6	= TWS6	; For compatibility
                 .equ	TWS7	= 7	; TWI Status
                 .equ	I2S7	= TWS7	; For compatibility
                 
                 ; TWDR - TWI Data register
                 .equ	I2DR	= TWDR	; For compatibility
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	I2AR	= TWAR	; For compatibility
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EEWEE	= EEMWE	; For compatibility
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 .equ	SM0	= 4	; Sleep Mode Select
                 .equ	SM1	= 5	; Sleep Mode Select
                 .equ	SM2	= 6	; Sleep Mode Select
                 .equ	SE	= 7	; Sleep Enable
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	MCUSR	= MCUCSR	; For compatibility
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; SPMCR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write Section Read Enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PUD	= 2	; Pull-up Disable
                 .equ	ADHSM	= 4	; ADC High Speed Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADCSR	= ADCSRA	; For compatibility
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADFR	= 5	; ADC  Free Running Select
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	BODEN	= 6	; Brown out detector enable
                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	CKOPT	= 4	; Oscillator Options
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	WTDON	= 6	; Enable watchdog
                 .equ	RSTDISBL	= 7	; Disable reset
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 1024
                 .equ	RAMEND	= 0x045f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x01ff
                 .equ	EEPROMEND	= 0x01ff
                 .equ	EEADRBITS	= 9
                 #pragma AVRPART MEMORY PROG_FLASH 8192
                 #pragma AVRPART MEMORY EEPROM 512
                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0xc00
                 .equ	NRWW_STOP_ADDR	= 0xfff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0xbff
                 .equ	PAGESIZE	= 32
                 .equ	FIRSTBOOTSTART	= 0xf80
                 .equ	SECONDBOOTSTART	= 0xf00
                 .equ	THIRDBOOTSTART	= 0xe00
                 .equ	FOURTHBOOTSTART	= 0xc00
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                 .equ	OC2addr	= 0x0003	; Timer/Counter2 Compare Match
                 .equ	OVF2addr	= 0x0004	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0005	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0006	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0007	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x0008	; Timer/Counter1 Overflow
                 .equ	OVF0addr	= 0x0009	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x000a	; Serial Transfer Complete
                 .equ	URXCaddr	= 0x000b	; USART, Rx Complete
                 .equ	UDREaddr	= 0x000c	; USART Data Register Empty
                 .equ	UTXCaddr	= 0x000d	; USART, Tx Complete
                 .equ	ADCCaddr	= 0x000e	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x000f	; EEPROM Ready
                 .equ	ACIaddr	= 0x0010	; Analog Comparator
                 .equ	TWIaddr	= 0x0011	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0012	; Store Program Memory Ready
                 
                 .equ	INT_VECTORS_SIZE	= 19	; size in words
                 
                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                 
                 #endif  /* _M8DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;Die Benutzung der Software ist mit folgenden Bedingungen verbunden:
                 
                 
                 #define POWER_RANGE 200
                 #define MIN_RC_PULS 1100
                 
                 ; falling->rising intervals
                 #define MAX_INT_FR  25000
                 #define MIN_INT_FR  15000
                 
                 ; rising->falling intervals
                 #define MAX_INT_RF  2200
                 #define MIN_INT_RF  800
                 
                 .macro EvaluatePWC
                                 cbr     flags1, (1<<EVAL_RC_PULS)
                                 sbrs    flags1, RC_PULS_UPDATED
                                 rjmp    eval_rc_p90
                                 lds     temp1, new_rcpuls_l
                                 lds     temp2, new_rcpuls_h
                                 cbr     flags1, (1<<RC_PULS_UPDATED) ; rc impuls value is read out
                                 subi    temp1, low  (MIN_RC_PULS*CLK_SCALE)
                                 sbci    temp2, high (MIN_RC_PULS*CLK_SCALE)
                                 brcc    eval_rc_p00
                                 clr     temp1
                                 clr     temp2
                 eval_rc_p00:    lsr     temp2
                                 ror     temp1
                                 lsr     temp2
                                 ror     temp1
                 .if CLK_SCALE==2
                                 lsr     temp2   ; actual 0->400
                                 ror     temp1
                 .endif
                                 mov     temp3, temp1            
                                 subi    temp1, POWER_RANGE
                                 brcs    eval_rc_p10
                                 ldi     temp3, POWER_RANGE
                 eval_rc_p10:    mov     ZH, temp3
                 eval_rc_p90:    ret
                 
                 .endmacro
                 ;
                 
                 
                   cbi     ADCSRA, ADEN          ; disable ADC
                   in      temp1, SFIOR
                   sbr     temp1, (1<<ACME)      ; switch to comparator multiplexed
                   out     SFIOR, temp1
                 .endmacro  
                 
                 .macro ACNormal
                    cbr  temp1, (1<<ACME)        ; set to AN1
                    out  SFIOR, temp1
                    sbi  ADCSRA, ADEN            ; enable ADC
                 .endmacro  
                 
                 .macro ACChannel 
                    ldi   temp1, @0              
                    out   ADMUX, temp1
                 .endmacro  
                 
                 #define Typ "Qynx  20"
                 
                 ; PORT  definities *************************************************************
                 
                 ;PORT B
                 
                 #define    CpFET           1      ; Aansturing FET plus
                 #define    BpFET           2      ; Aansturing FET plus
                 #define    ApFET           3      ; Aansturing FET plus
                 
                 #define    INIT_PB         (1<<ApFET) + (1<<BpFET) + (1<< CpFET)
                 #define    DIR_PB          (1<<ApFET) + (1<<BpFET) + (1<< CpFET)
                 #define    BRAKE_PB        0
                 
                 ;PORT C
                 
                 #define    AnFET           0      ; Aansturing FET massa
                 #define    BnFET           1      ; Aansturing FET massa 
                 #define    CnFET           2      ; Aansturing FET massa
                 #define    mux_a           3      ;
                 #define    mux_b           4      ;
                 #define    mux_c           5      ;
                 
                 #define    INIT_PC         0
                 #define    DIR_PC          (1<<AnFET) + (1<<BnFET) + (1<< CnFET)
                 #define    BRAKE_PC        (1<<AnFET) + (1<<BnFET) + (1<< CnFET)
                 
                 ;PORT D
                 
                 #define    DbgLED          2      ; LED
                 #define    rcp_in          3      ; INT1 PPM input
                 #define    c_comp          6
                 
                 
                 #define    INIT_PD         (1<<DbgLED) ; Led staat uit
                 #define    DIR_PD          (1<<DbgLED)
                 #define    BRAKE_PD        0
                 
                 #define LED_UIT            sbi     PORTD,2 ; LED uit
                 #define LED_AAN            cbi     PORTD,2 ; LED aan
                 
                 #define DbgLEDOn           sbi     PORTD,2
                 #define DbgLEDOff          cbi     PORTD,2
                 
                 ; FET Control *****************************************************************
                 
                 #define ApFET_on           cbi     PORTB,3
                 #define ApFET_off          sbi     PORTB,3
                 
                 #define BpFET_on           cbi     PORTB,2
                 #define BpFET_off          sbi     PORTB,2
                 
                 #define CpFET_on           cbi     PORTB,1
                 #define CpFET_off          sbi     PORTB,1
                 
                 #define AnFET_on           sbi     PORTC,0
                 #define AnFET_off          cbi     PORTC,0
                 
                 #define BnFET_on           sbi     PORTC,1
                 #define BnFET_off          cbi     PORTC,1
                 
                 #define CnFET_on           sbi     PORTC,2
                 #define CnFET_off          cbi     PORTC,2
                 
                 ; Comparator definitions ******************************************************
                 
                 .macro AcInit
                   ACMultiplexed
                 .endmacro
                 
                 
                 .macro AcPhaseA
                   ACChannel mux_a
                 .endmacro
                 
                 
                 .macro AcPhaseB
                   ACChannel mux_b
                 .endmacro
                 
                 
                 .macro AcPhaseC
                   ACChannel mux_c
                 .endmacro
                 
                 ;*************************
                 ; Parameters             *
                 ;*************************
                 #undef     MOT_BRAKE      
                 #undef     READ_CALIBRATION
                 #define    F_CPU           16000000              ; 16Mhz internal RC oscilator 
                 
                 ;*************************
                 ; Timings                *
                 ;*************************
                 
                 #define    CHANGE_TIMEOUT  0x01
                 #define    CHANGE_TOT_LOW  0x01
                 
                 #define    MIN_DUTY        3*POWER_RANGE/100     ; Min power 3%
                 
                 #define    PWR_MAX_RPM1    POWER_RANGE/4
                 #define    PWR_MAX_RPM2    POWER_RANGE/2
                 
                 #define    PWR_STARTUP     5*POWER_RANGE/100             ;  5%
                 #define    PWR_MAX_STARTUP 12*POWER_RANGE/100    ; 12%
                 
                 #define    timeoutSTART    65000
                 #define    timeoutMIN      48000
                 
                 #define    PWR_RANGE1      0x40  ; ( ~2400 RPM )
                 #define    PWR_RANGE2      0x20  ; ( ~4800 RPM )
                 
                 #define    ENOUGH_GOODIES  60
                 
                 ;
                 ;Die Benutzung der Software ist mit folgenden Bedingungen verbunden:
                 ;
                 ;1. Da ich alles kostenlos zur Verfügung stelle, gebe ich keinerlei Garantie
                 ;   und übernehme auch keinerlei Haftung für die Folgen der Benutzung.
                 ;
                 ;2. Die Software ist ausschließlich zur privaten Nutzung bestimmt. Ich
                 ;   habe nicht geprüft, ob bei gewerblicher Nutzung irgendwelche Patentrechte
                 ;   verletzt werden oder sonstige rechtliche Einschränkungen vorliegen.
                 ;
                 ;3. Jeder darf Änderungen vornehmen, z.B. um die Funktion seinen Bedürfnissen
                 ;   anzupassen oder zu erweitern. Ich würde mich freuen, wenn ich weiterhin als
                 ;   Co-Autor in den Unterlagen erscheine und mir ein Link zur entprechenden Seite
                 ;   (falls vorhanden) mitgeteilt wird.
                 ;
                 ;4. Auch nach den Änderungen sollen die Software weiterhin frei sein, d.h. kostenlos bleiben.
                 ;
                 ;!! Wer mit den Nutzungbedingungen nicht einverstanden ist, darf die Software nicht nutzen !!
                 
                 #if defined(_include_ppm_inc_)
                   .include "ppm_light.inc"
                 
                 #endif
                 
                 #if (rcp_in == 3)
                   #define    micp_dis     0x00       ; disable ext0int
                   #define    micp_en      (1<<INT1)  ; enable ext0int
                   #define    micp_r_edge  (1<<ISC11)+(1<<ISC10)
                   #define    micp_f_edge  (1<<ISC11)
                   #define    micp_m_test  ISC10
                   #define    __ext_int1   rjmp ext_int1_isr
                   .macro __ext_int1_isr
                     __ext_micp_isr
                   .endmacro
                 #endif
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; external interrupt0 = rc pulse input
                 .macro __ext_micp_isr
                                 in      i_temp1, TCNT1L
                                 in      i_temp2, TCNT1H
                                 in      i_sreg, SREG
                                 sbis    PIND, rcp_in
                                 rjmp    falling_edge
                                 
                                 ldi     i_temp3, micp_f_edge
                                 out     MCUCR, i_temp3                            ; set next int0 to falling edge
                                 mov     start_rcpuls_l, i_temp1
                                 mov     start_rcpuls_h, i_temp2
                                 rjmp    micp_exit
                 
                 micp_fail:      tst     control_timeout
                                 breq    micp_exit
                                 dec     control_timeout
                                 rjmp    micp_exit
                                 
                 falling_edge:
                                 ldi     i_temp3, micp_r_edge
                                 out     MCUCR, i_temp3                            ; set next int0 to rising edge
                                 
                                 sts     stop_rcpuls_l, i_temp1                    ; prepare next interval evaluation
                                 sts     stop_rcpuls_h, i_temp2
                                 sub     i_temp1, start_rcpuls_l
                                 sbc     i_temp2, start_rcpuls_h
                                 ; save impuls length
                                 sts     new_rcpuls_l, i_temp1
                                 sts     new_rcpuls_h, i_temp2
                                 cpi     i_temp1, low (MAX_INT_RF*CLK_SCALE)
                                 ldi     i_temp3, high(MAX_INT_RF*CLK_SCALE)       ; test range high
                                 cpc     i_temp2, i_temp3
                                 brsh    micp_fail                                 ; through away
                                 cpi     i_temp1, low (MIN_INT_RF*CLK_SCALE)
                                 ldi     i_temp3, high(MIN_INT_RF*CLK_SCALE)       ; test range low
                                 cpc     i_temp2, i_temp3
                                 brlo    micp_fail                                 ; through away
                                 sbr     flags1, (1<<RC_PULS_UPDATED)              ; set to rc impuls value is ok !
                                 ldi     i_temp1, CONTROL_TOT*CLK_SCALE
                                 mov     control_timeout, i_temp1
                 micp_exit:   
                                 out     SREG, i_sreg
                                 reti
                 .endm
                 
                 .macro enable_input
                                 ldi     temp4, micp_en
                                 out     GIMSK, temp4                              
                 .endm 
                 
                 .macro disable_input
                                 ldi     temp4, micp_dis
                                 out     GIMSK, temp4
                 .endm 
                 
                 .macro init_input
                                 ldi     temp1, micp_r_edge
                                 out     MCUCR, temp1                              
                                 enable_input
                 .endm
                 #endif 
                 
                 
                 .equ    NO_POWER         = 256 - MIN_DUTY       ; (POWER_OFF)
                 .equ    MAX_POWER        = 256 - POWER_RANGE    ; (FULL_POWER)
                 .equ    CONTROL_TOT      = 50                   ; time = NUMBER x 64ms
                 .equ    CURRENT_ERR_MAX  = 3                    ; performs a reset after MAX errors
                 
                 .equ    T1STOP           = 0x00
                 .equ    T1CK8            = 0x02
                 .equ    CLK_SCALE        = F_CPU / 8000000
                 
                 ;**** **** **** **** ****
                 ; Register Definitions
                 .def    i_sreg           = r1   ; status register save in interrupts
                 .def    tcnt0_power_on   = r2   ; timer0 counts nFETs are switched on
                 ;.def   ...              = r3   ; 
                 ;.def   ...              = r4   ; 
                 ;.def   ...              = r5   ;
                 .def    tcnt0_pwroff     = r6   ; timer0 counts nFETs are switched off
                 
                 .def    start_rcpuls_l   = r7
                 .def    start_rcpuls_h   = r8
                 .def    motor_count      = r9
                 ;.def                    = r10
                 .def    control_timeout  = r11
                 .def    current_err      = r12  ; counts consecutive current errors
                 
                 .def    sys_control      = r13
                 .def    t1_timeout       = r14
                 .def    run_control      = r15
                 
                 
                 .def    temp1            = r16  ; main temporary
                 .def    temp2            = r17  ; main temporary
                 .def    temp3            = r18  ; main temporary
                 .def    temp4            = r19  ; main temporary
                 
                 .def    i_temp1          = r20  ; interrupt temporary
                 .def    i_temp2          = r21  ; interrupt temporary
                 .def    i_temp3          = r22  ; interrupt temporary
                 
                 .def    flags0  = r23   ; state flags
                         .equ    OCT1_PENDING    = 0     ; if set, output compare interrunpt is pending
                         .equ    UB_LOW          = 1     ; set if accu voltage low
                         .equ    I_pFET_HIGH     = 2     ; set if over-current detect
                         .equ    GET_STATE       = 3     ; set if state is to be send
                         .equ    C_FET           = 4     ; if set, C-FET state is to be changed
                         .equ    A_FET           = 5     ; if set, A-FET state is to be changed
                              ; if neither 1 nor 2 is set, B-FET state is to be changed
                         .equ    I_OFF_CYCLE     = 6     ; if set, current off cycle is active
                         .equ    T1OVFL_FLAG     = 7     ; each timer1 overflow sets this flag - used for voltage + current watch
                 
                 .def    flags1  = r24   ; state flags
                         .equ    POWER_OFF       = 0     ; switch fets on disabled
                         .equ    FULL_POWER      = 1     ; 100% on - don't switch off, but do OFF_CYCLE working
                         .equ    CALC_NEXT_OCT1  = 2     ; calculate OCT1 offset, when wait_OCT1_before_switch is called
                         .equ    RC_PULS_UPDATED = 3     ; new rc-puls value available
                         .equ    EVAL_RC_PULS    = 4     ; if set, new rc puls is evaluated, while waiting for OCT1
                         .equ    EVAL_SYS_STATE  = 5     ; if set, overcurrent and undervoltage are checked
                         .equ    EVAL_RPM        = 6     ; if set, next PWM on should look for current
                         .equ    EVAL_PWM        = 7     ; if set, PWM should be updated
                 
                 .def    flags2  = r25
                         .equ    RPM_RANGE1      = 0     ; if set RPM is lower than 1831 RPM
                         .equ    RPM_RANGE2      = 1     ; if set RPM is between 1831 RPM and 3662 RPM
                         .equ    SCAN_TIMEOUT    = 2     ; if set a startup timeout occurred
                         .equ    POFF_CYCLE      = 3     ; if set one commutation cycle is performed without power
                         .equ    COMP_SAVE       = 4     ; if set ACO was high
                         .equ    STARTUP         = 5     ; if set startup-phase is active
                         .equ    RC_INTERVAL_OK  = 6     ; 
                         .equ    NO_SYNC         = 7     ; 
                 
                 ; here the XYZ registers are placed ( r26-r31)
                 
                 ; ZH = new_duty         ; PWM destination
                 
                 
                 ;**** **** **** **** ****
                 ; RAM Definitions
                 .dseg                                   ;EEPROM segment
                 .org SRAM_START
                 
000060           tcnt1_sav_l:    .byte   1       ; actual timer1 value
000061           tcnt1_sav_h:    .byte   1
000062           last_tcnt1_l:   .byte   1       ; last timer1 value
000063           last_tcnt1_h:   .byte   1
000064           timing_l:       .byte   1       ; holds time of 4 commutations 
000065           timing_h:       .byte   1
000066           timing_x:       .byte   1
                 
000067           timing_acc_l:   .byte   1       ; holds the average time of 4 commutations 
000068           timing_acc_h:   .byte   1
000069           timing_acc_x:   .byte   1
                 
00006a           rpm_l:          .byte   1       ; holds the average time of 4 commutations 
00006b           rpm_h:          .byte   1
00006c           rpm_x:          .byte   1
                 
00006d           wt_comp_scan_l: .byte   1       ; time from switch to comparator scan
00006e           wt_comp_scan_h: .byte   1       
00006f           com_timing_l:   .byte   1       ; time from zero-crossing to switch of the appropriate FET
000070           com_timing_h:   .byte   1
000071           wt_OCT1_tot_l:  .byte   1       ; OCT1 waiting time
000072           wt_OCT1_tot_h:  .byte   1
000073           zero_wt_l:      .byte   1
000074           zero_wt_h:      .byte   1
000075           last_com_l:     .byte   1
000076           last_com_h:     .byte   1
                 
000077           stop_rcpuls_l:  .byte   1
000078           stop_rcpuls_h:  .byte   1
000079           new_rcpuls_l:   .byte   1
00007a           new_rcpuls_h:   .byte   1
                 
00007b           duty_offset:    .byte   1
00007c           goodies:        .byte   1
00007d           comp_state:     .byte   1
00007e           uart_command:   .byte   1
                 
00007f           uart_data:      .byte   100             ; only for debug requirements
                 
                 
                 ;**** **** **** **** ****
                 ; ATmega8 interrupts
                 
                 ;.equ   INT0addr=$001   ; External Interrupt0 Vector Address
                 ;.equ   INT1addr=$002   ; External Interrupt1 Vector Address
                 ;.equ   OC2addr =$003   ; Output Compare2 Interrupt Vector Address
                 ;.equ   OVF2addr=$004   ; Overflow2 Interrupt Vector Address
                 ;.equ   ICP1addr=$005   ; Input Capture1 Interrupt Vector Address
                 ;.equ   OC1Aaddr=$006   ; Output Compare1A Interrupt Vector Address
                 ;.equ   OC1Baddr=$007   ; Output Compare1B Interrupt Vector Address
                 ;.equ   OVF1addr=$008   ; Overflow1 Interrupt Vector Address
                 ;.equ   OVF0addr=$009   ; Overflow0 Interrupt Vector Address
                 ;.equ   SPIaddr =$00a   ; SPI Interrupt Vector Address
                 ;.equ   URXCaddr=$00b   ; USART Receive Complete Interrupt Vector Address
                 ;.equ   UDREaddr=$00c   ; USART Data Register Empty Interrupt Vector Address
                 ;.equ   UTXCaddr=$00d   ; USART Transmit Complete Interrupt Vector Address
                 ;.equ   ADCCaddr=$00e   ; ADC Interrupt Vector Address
                 ;.equ   ERDYaddr=$00f   ; EEPROM Interrupt Vector Address
                 ;.equ   ACIaddr =$010   ; Analog Comparator Interrupt Vector Address
                 ;.equ   TWIaddr =$011   ; Irq. vector address for Two-Wire Interface
                 ;.equ   SPMaddr =$012   ; SPM complete Interrupt Vector Address
                 ;.equ   SPMRaddr =$012  ; SPM complete Interrupt Vector Address
                 ;-----bko-----------------------------------------------------------------
                 ; helper macroses
                 #if !defined(__ext_int0)
                  #define __ext_int0 reti 
                  .macro __ext_int0_isr
                  .endmacro
                 #endif
                 
                 #if !defined(__ext_int1)
                 #endif
                 ;**** **** **** **** ****
                 .cseg
                 .org 0
                 ;-----bko-----------------------------------------------------------------
                 ; reset and interrupt jump table
                 
000000 c01c                      rjmp    reset
000001 9518                      __ext_int0          ; ext_int0
000002 c069                      __ext_int1          ; ext_int1
000003 9518                      reti                ; t2oc_int
000004 9518                      reti                ; t2ovfl_int
000005 9518                      reti                ; icp1
000006 c08c                      rjmp    t1oca_int
000007 9518                      reti                ; t1ocb_int
000008 c08e                      rjmp    t1ovfl_int
000009 c099                      rjmp    t0ovfl_int
00000a 9518                      reti                ; spi_int
00000b 9518                      reti                ; urxc
00000c 9518                      reti                ; udre
00000d 9518                      reti                ; utxc
00000e 9518                      reti                ; adc_int
00000f 9518                      reti                ; eep_int
000010 9518                      reti                ; aci_int
000011 9518                      reti                ; wire2_int
000012 9518                      reti                ; spmc_int
                 
                 
000013 0a0d      version:        .db     0x0d, 0x0a
000014 6b62
000015 7951
000016 786e
000017 2020
000018 3032
000019 3134
00001a 7230
00001b 3630                      .db     "bk",Typ,"410r06"
00001c 0a0d                      .db     0x0d, 0x0a
                 
                 ;******************************************************************************
                 ;* MACRO
                 ;*      SetPWMi
                 ;* DECRIPTION
                 ;*      Set PWM immidiate
                 ;* USAGE
                 ;*      SetPWMi(val)
                 ;* STATISTICS
                 ;*      Register usage: none
                 ;******************************************************************************
                 .macro SetPWMi
                                 push    temp1
                                 ldi     temp1, @0
                                 com     temp1
                                 rcall   set_pwm
                 ;                rcall   eval_power_state
                                 pop     temp1
                 .endmacro
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; init after reset
                 
00001d e004      reset:          ldi     temp1, high(RAMEND)     ; stack = RAMEND
00001e bf0e                      out     SPH, temp1
00001f e50f                      ldi     temp1, low(RAMEND)
000020 bf0d                      out     SPL, temp1
                 
                 #ifdef READ_CALIBRATION
                 #endif
                 
                         ; portB
000021 e00e                      ldi     temp1, INIT_PB
000022 bb08                      out     PORTB, temp1
000023 e00e                      ldi     temp1, DIR_PB
000024 bb07                      out     DDRB, temp1
                 
                         ; portC
000025 e000                      ldi     temp1, INIT_PC
000026 bb05                      out     PORTC, temp1
000027 e007                      ldi     temp1, DIR_PC
000028 bb04                      out     DDRC, temp1
                 
                         ; portD
000029 e004                      ldi     temp1, INIT_PD
00002a bb02                      out     PORTD, temp1
00002b e004                      ldi     temp1, DIR_PD
00002c bb01                      out     DDRD, temp1
                 
                         ; timer0: PWM + beep control = 0x02     ; start timer0 with CK/8 (0.5³s/count)
00002d e002                      ldi     temp1, 0x02
00002e bf03                      out     TCCR0, temp1
                 
                         ; timer1: commutation control = 0x02    ; start timer1 with CK/8 (0.5³s/count)
00002f e002                      ldi     temp1, T1CK8
000030 bd0e                      out     TCCR1B, temp1
                 
                         ; reset state flags
000031 2777                      clr     flags0
000032 2788                      clr     flags1
000033 2799                      clr     flags2
                 
                         ; clear RAM
000034 27bb                      clr     XH
000035 e6a0                      ldi     XL, low (SRAM_START)
000036 2700                      clr     temp1
000037 930d      clear_ram:      st      X+, temp1
000038 38a0                      cpi     XL, uart_data+1
000039 f3e8                      brlo    clear_ram
                 
                         ; power off
00003a d259                      rcall   switch_power_off
                 
                         ; reset rc puls timeout
00003b e604                      ldi     temp1, CONTROL_TOT*CLK_SCALE
00003c 2eb0                      mov     control_timeout, temp1
                                 
00003d d0bd                      rcall   wait260ms       ; wait a while
00003e d0bc                      rcall   wait260ms
                 
00003f d08f                      rcall   beep_f1
000040 d0ae                      rcall   wait30ms
000041 d090                      rcall   beep_f2
000042 d0ac                      rcall   wait30ms
000043 d091                      rcall   beep_f3
000044 d0aa                      rcall   wait30ms
                 
                 control_start:  ; init variables
000045 930f
000046 e005
000047 9500
000048 d0f0
000049 910f                      SetPWMi(MIN_DUTY-1)
00004a e000                      ldi     temp1, 0                ; reset error counters
00004b 2ec0                      mov     current_err,temp1
00004c 2ed0                      mov     sys_control, temp1
                 
                         ; init registers and interrupts
00004d e105                      ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
00004e bf08                      out     TIFR, temp1             ; clear TOIE1,OCIE1A & TOIE0
00004f bf09                      out     TIMSK, temp1            ; enable TOIE1,OCIE1A & TOIE0 interrupts
                 
000050 9478                      sei                             ; enable all interrupts
                 
000051 e00c
000052 bf05
000053 e830
000054 bf3b                      init_input
000055 e02a      i_rc_puls1:     ldi     temp3, 10               ; wait for this count of receiving power off
000056 ff83      i_rc_puls2:     sbrs    flags1, RC_PULS_UPDATED
000057 cffe                      rjmp    i_rc_puls2
000058 9100 0079                 lds     temp1, new_rcpuls_l
00005a 9110 007a                 lds     temp2, new_rcpuls_h
00005c 7f87                      cbr     flags1, (1<<RC_PULS_UPDATED) ; rc impuls value is read out
00005d 5908                      subi    temp1, low  (MIN_RC_PULS*CLK_SCALE)     ; power off received ?
00005e 4018                      sbci    temp2, high (MIN_RC_PULS*CLK_SCALE)
00005f f7a8                      brcc    i_rc_puls1              ; no - reset counter
000060 952a                      dec     temp3                   ; yes - decrement counter
000061 f7a1                      brne    i_rc_puls2              ; repeat until zero
000062 94f8                      cli                             ; disable all interrupts
000063 d074                      rcall   beep_f4                 ; signal: rcpuls ready
000064 d073                      rcall   beep_f4
000065 d072                      rcall   beep_f4
000066 9478                      sei                             ; enable all interrupts
                 
000067 e10e                      ldi     temp1, 30
000068 9300 007b                 sts     duty_offset, temp1
                 
00006a d14a                      rcall   set_all_timings
                 
00006b c270                      rjmp    init_startup
                 ;-----bko-----------------------------------------------------------------
                 ext_int0_isr:   __ext_int0_isr
00006c b54c
00006d b55d
00006e b61f
00006f 9b83
000070 c009
000071 e068
000072 bf65
000073 2e74
000074 2e85
000075 c01b
000076 20bb
000077 f0c9
000078 94ba
000079 c017
00007a e06c
00007b bf65
00007c 9340 0077
00007e 9350 0078
000080 1947
000081 0958
000082 9340 0079
000084 9350 007a
000086 3340
000087 e161
000088 0756
000089 f760
00008a 3440
00008b e066
00008c 0756
00008d f340
00008e 6088
00008f e644
000090 2eb4
000091 be1f
000092 9518      ext_int1_isr:   __ext_int1_isr
                 ;-----bko-----------------------------------------------------------------
                 ; output compare timer1 interrupt
000093 b61f      t1oca_int:      in      i_sreg, SREG
000094 7f7e                      cbr     flags0, (1<<OCT1_PENDING) ; signal OCT1 passed
000095 be1f                      out     SREG, i_sreg
000096 9518                      reti
                 ;-----bko-----------------------------------------------------------------
                 ; overflow timer1 / happens all 32768³s / 65536³s
000097 b61f      t1ovfl_int:     in      i_sreg, SREG
000098 6870                      sbr     flags0, (1<<T1OVFL_FLAG)
                 
000099 20ee                      tst     t1_timeout
00009a f009                      breq    t1ovfl_10
00009b 94ea                      dec     t1_timeout
                 
00009c 20bb      t1ovfl_10:      tst     control_timeout
00009d f411                      brne    t1ovfl_20
00009e 27ff                      clr     ZH
00009f c001                      rjmp    t1ovfl_99
0000a0 94ba      t1ovfl_20:      dec     control_timeout
                 
0000a1 be1f      t1ovfl_99:      out     SREG, i_sreg
0000a2 9518                      reti
                 ;-----bko-----------------------------------------------------------------
                 ; timer0 overflow interrupt
0000a3 b61f      t0ovfl_int:     in      i_sreg, SREG
                 ;                DbgLEDOff
0000a4 fd76                      sbrc    flags0, I_OFF_CYCLE
0000a5 c014                      rjmp    t0_on_cycle
                 
                 t0_off_cycle:   
0000a6 be62                      out     TCNT0, tcnt0_pwroff     ; reload t0
                                 ; mirror inverted ACO to bit-var
0000a7 6190                      sbr     flags2, (1<<COMP_SAVE)
0000a8 9945                      sbic    ACSR, ACO               
0000a9 7e9f                      cbr     flags2, (1<<COMP_SAVE)
                                 ; PWM state = off cycle
0000aa 6470                      sbr     flags0, (1<<I_OFF_CYCLE)
                                 ; We can just turn them all off as we only have one nFET on at a
                                 ; time, and interrupts are disabled during beeps.
0000ab 98aa                      CnFET_off
0000ac 98a8                      AnFET_off
0000ad 98a9                      BnFET_off
                 
                 
0000ae 2d46                      mov     i_temp1, tcnt0_pwroff
0000af 3040                      cpi     i_temp1, 0
0000b0 f021                      breq    t0_on_cycle_t1
0000b1 3041                      cpi     i_temp1, 1
0000b2 f039                      breq    t0_on_cycle_t0
                 
0000b3 be1f                      out     SREG, i_sreg
0000b4 9518                      reti
                 
                 t0_on_cycle_t1:
0000b5 0000                      nop
0000b6 0000                      nop                
0000b7 0000                      nop
0000b8 0000                      nop                
0000b9 0000                      nop
                 ;                nop                
                 ;                nop
                 ;                nop                
                                 
                                 
                 t0_on_cycle_t0:
                 ;                nop
                 ;                nop      
                 ;                nop
                 ;                nop      
                 ;                DbgLEDOn          
                 
                 
                 t0_on_cycle:
0000ba fd80                      sbrc    flags1, POWER_OFF
0000bb c009                      rjmp    t0_on_cycle_tcnt
                                 ; switch appropriate nFET on as soon as possible
0000bc ff74                      sbrs    flags0, C_FET           ; is Cn choppered ?
0000bd c002                      rjmp    test_AnFET_on                   ; .. no - test An
0000be 9aaa                      CnFET_on                        ; Cn on
0000bf c005                      rjmp    t0_on_cycle_tcnt
0000c0 ff75      test_AnFET_on:  sbrs    flags0, A_FET           ; is An choppered ?
0000c1 c002                      rjmp    sw_BnFET_on                     ; .. no - Bn has to be choppered
0000c2 9aa8                      AnFET_on                        ; An on
0000c3 c001                      rjmp    t0_on_cycle_tcnt
                 sw_BnFET_on:    
0000c4 9aa9                      BnFET_on                        ; Bn on
                 t0_on_cycle_tcnt:
0000c5 7b7f                      cbr     flags0, (1<<I_OFF_CYCLE); PWM state = on cycle
0000c6 2d42                      mov     i_temp1, tcnt0_power_on
0000c7 7f8d                      cbr     flags1, (1<<FULL_POWER)
0000c8 3348                      cpi     i_temp1, MAX_POWER
0000c9 f410                      brsh    t0_on_cycle_not_full_power
0000ca 6082                      sbr     flags1, (1<<FULL_POWER)
0000cb 6470                      sbr     flags0, (1<<I_OFF_CYCLE)
                 t0_on_cycle_not_full_power:
0000cc be22                      out     TCNT0, tcnt0_power_on   ; reload t0
0000cd be1f                      out     SREG, i_sreg
0000ce 9518                      reti                   
                 ;-----bko-----------------------------------------------------------------
                 ; beeper: timer0 is set to 1³s/count
0000cf ec38      beep_f1:        ldi     temp4, 200
0000d0 e510                      ldi     temp2, 80
0000d1 c009                      rjmp    beep
                 
0000d2 eb34      beep_f2:        ldi     temp4, 180
0000d3 e614                      ldi     temp2, 100
0000d4 c006                      rjmp    beep
                 
0000d5 ea30      beep_f3:        ldi     temp4, 160
0000d6 e718                      ldi     temp2, 120
0000d7 c003                      rjmp    beep
                 
0000d8 e634      beep_f4:        ldi     temp4, 100
0000d9 ec18                      ldi     temp2, 200
0000da c000                      rjmp    beep
                 
0000db 2700      beep:           clr     temp1
0000dc bf02                      out     TCNT0, temp1
0000dd 98c2                      BpFET_on                ; BpFET on
0000de 9aa8                      AnFET_on                ; CnFET on
0000df b702      beep_BpCn10:    in      temp1, TCNT0
0000e0 3400                      cpi     temp1, 32*CLK_SCALE             ; 32³s on
0000e1 f7e9                      brne    beep_BpCn10
0000e2 9ac2                      BpFET_off               ; BpFET off
0000e3 98a8                      AnFET_off               ; CnFET off
0000e4 e120                      ldi     temp3, 8*CLK_SCALE              ; 2040³s off
0000e5 2700      beep_BpCn12:    clr     temp1
0000e6 bf02                      out     TCNT0, temp1
0000e7 b702      beep_BpCn13:    in      temp1, TCNT0
0000e8 1703                      cp      temp1, temp4
0000e9 f7e9                      brne    beep_BpCn13
0000ea 952a                      dec     temp3
0000eb f7c9                      brne    beep_BpCn12
0000ec 951a                      dec     temp2
0000ed f769                      brne    beep
0000ee 9508                      ret
                 
0000ef e11e      wait30ms:       ldi     temp2, 15*CLK_SCALE
0000f0 e120      beep_BpCn20:    ldi     temp3, 8*CLK_SCALE
0000f1 2700      beep_BpCn21:    clr     temp1
0000f2 bf02                      out     TCNT0, temp1
0000f3 b702      beep_BpCn22:    in      temp1, TCNT0
0000f4 3f0f                      cpi     temp1, 255
0000f5 f7e9                      brne    beep_BpCn22
0000f6 952a                      dec     temp3
0000f7 f7c9                      brne    beep_BpCn21
0000f8 951a                      dec     temp2
0000f9 f7b1                      brne    beep_BpCn20
0000fa 9508                      ret
                 
                         ; 256 periods = 261ms silence
0000fb ef1e      wait260ms:      ldi     temp2, 127*CLK_SCALE    ; = 256
0000fc e120      beep2_BpCn20:   ldi     temp3, 8*CLK_SCALE
0000fd 2700      beep2_BpCn21:   clr     temp1
0000fe bf02                      out     TCNT0, temp1
0000ff b702      beep2_BpCn22:   in      temp1, TCNT0
000100 3f0f                      cpi     temp1, 255
000101 f7e9                      brne    beep2_BpCn22
000102 952a                      dec     temp3
000103 f7c9                      brne    beep2_BpCn21
000104 951a                      dec     temp2
000105 f7b1                      brne    beep2_BpCn20
000106 9508                      ret                
                 ;-----bko-----------------------------------------------------------------
                 tcnt1_to_temp:  
000107 e030
000108 bf3b                      disable_input
000109 e030                      ldi     temp4, T1STOP           ; stop timer1
00010a bd3e                      out     TCCR1B, temp4
00010b e032                      ldi     temp4, T1CK8            ; preload temp with restart timer1
00010c b50c                      in      temp1, TCNT1L           ;  - the preload cycle is needed to complete stop operation
00010d b51d                      in      temp2, TCNT1H
00010e bd3e                      out     TCCR1B, temp4
00010f 9508                      ret                             ; !!! ext0int stays disabled - must be enabled again by caller
                         ; there seems to be only one TEMP register in the AVR
                         ; if the ext0int interrupt falls between readad LOW value while HIGH value is captured in TEMP and
                         ; read HIGH value, TEMP register is changed in ext0int routine
                 ;-----bko-----------------------------------------------------------------
                 evaluate_rc_puls:
000110 7e8f
000111 ff83
000112 c015
000113 9100 0079
000115 9110 007a
000117 7f87
000118 5908
000119 4018
00011a f410
00011b 2700
00011c 2711
00011d 9516
00011e 9507
00011f 9516
000120 9507
000121 9516
000122 9507
000123 2f20
000124 5c08
000125 f008
000126 ec28
000127 2ff2
000128 9508                      EvaluatePWC
                 ;-----bko-----------------------------------------------------------------
                 evaluate_sys_state:
000129 7d8f                      cbr     flags1, (1<<EVAL_SYS_STATE)
00012a ff77                      sbrs    flags0, T1OVFL_FLAG
00012b c00a                      rjmp    eval_sys_s99
                 
                         ; do it not more often as every 32³s
00012c 777f                      cbr     flags0, (1<<T1OVFL_FLAG)
                 
                         ; control current
00012d c005      eval_sys_i:     rjmp    eval_sys_i_ok
                 
00012e 2d4c                      mov     i_temp1, current_err
00012f 3043                      cpi     i_temp1, CURRENT_ERR_MAX
000130 f430                      brcc    panic_exit
000131 94c3                      inc     current_err
000132 c003                      rjmp    eval_sys_ub
                 
000133 20cc      eval_sys_i_ok:  tst     current_err
000134 f009                      breq    eval_sys_ub
000135 94ca                      dec     current_err
                 
                 eval_sys_ub:    
000136 9508      eval_sys_s99:   ret
                 
                 panic_exit:     ; !!!!!! OVERCURRENT !!!!!!!!
000137 94f8                      cli
000138 cee4                      rjmp    reset
                 ;-----bko-----------------------------------------------------------------
                 ;******************************************************************************
                 ;* FUNCTION
                 ;*      set_pwm
                 ;* DECRIPTION
                 ;*      Calculates tcnt0 values for ON and off cycles.
                 ;*      Performs PWM correction.
                 ;* USAGE
                 ;*      temp1
                 ;* STATISTICS
                 ;*      Register usage: temp1
                 ;******************************************************************************
                 set_pwm:
                 ;                inc     temp1                   ; Make it shorter by 3 cycles
                 ;                inc     temp1
                 ;                inc     temp1
000139 2e20                      mov     tcnt0_power_on, temp1
00013a 5308                      subi    temp1, -POWER_RANGE     
00013b 9500                      com     temp1   
00013c 9503                      inc     temp1            
00013d 9503                      inc     temp1            
00013e 2e60                      mov     tcnt0_pwroff, temp1
00013f 9508                      ret
                 
                 ;******************************************************************************
                 ;* FUNCTION
                 ;*      eval_power_state
                 ;* DECRIPTION
                 ;*      Evaluates current state
                 ;* USAGE
                 ;*      temp1
                 ;* STATISTICS
                 ;*      Register usage: none
                 ;******************************************************************************
                 eval_power_state:
000140 3309                      cpi     temp1, MAX_POWER+1
000141 f410                      brsh    not_full_power
                                 ; FULL POWER
                 ;               sbr     flags1, (1<<FULL_POWER) ; tcnt0_power_on = MAX_POWER means FULL_POWER
000142 7f8e                      cbr     flags1, (1<<POWER_OFF)
                                 ;DbgLEDOn
000143 c005                      rjmp    eval_power_state_exit
000144 3f0a      not_full_power: cpi     temp1, NO_POWER
000145 f010                      brlo    neither_full_nor_off
                         ; POWER OFF
                 ;               cbr     flags1, (1<<FULL_POWER) ; tcnt0_power_on = NO_POWER means power off
000146 6081                      sbr     flags1, (1<<POWER_OFF)
                                 ;DbgLEDOff
000147 c001                      rjmp    eval_power_state_exit
                 neither_full_nor_off:
                 ;               cbr     flags1, (1<<FULL_POWER) ; tcnt0_power_on = MAX_POWER means FULL_POWER
000148 7f8e                      cbr     flags1, (1<<POWER_OFF)
                                 ;DbgLEDOff
                 eval_power_state_exit:    
000149 fd93                      sbrc    flags2, POFF_CYCLE
00014a 6081                      sbr     flags1, (1<<POWER_OFF)
00014b 9508                      ret
                 ;******************************************************************************
                 ;* FUNCTION
                 ;*      set_new_duty
                 ;* DECRIPTION
                 ;*     1) Evaluates duty cycle
                 ;*     2) Limits power to sys_control
                 ;*     3) Limits starup power
                 ;*     4) Limits RPM ranges power
                 ;*     5) Increments sys_control up to POWER_RANGE
                 ;* USAGE
                 ;*      ZH (0-POWER_RANGE)
                 ;* STATISTICS
                 ;*      Register usage: temp1, temp2, temp3 
                 ;******************************************************************************
                 set_new_duty:   
00014c 2f0f                      mov     temp1, ZH
00014d 2d1d                      mov     temp2, sys_control      ; Limit PWM to sys_control
00014e 1701                      cp      temp1, temp2
00014f f020                      brcs    set_new_duty10
000150 2f01                      mov     temp1, temp2
000151 3c18                      cpi     temp2, POWER_RANGE
000152 f009                      breq    set_new_duty10
000153 94d3                      inc     sys_control             ; Build up sys_control to POWER_RANGE
000154 9110 0066 set_new_duty10: lds     temp2, timing_x
000156 2311                      tst     temp2
000157 f421                      brne    set_new_duty12
000158 9110 0065                 lds     temp2, timing_h         ; get actual RPM reference high
00015a 3810                      cpi     temp2, PWR_RANGE1*CLK_SCALE ; lower range1 ?
00015b f038                      brcs    set_new_duty20          ; on carry - test next range ; lower as range1
00015c 6091      set_new_duty12: sbr     flags2, (1<<RPM_RANGE1)
00015d 6092                      sbr     flags2, (1<<RPM_RANGE2)
00015e e312                      ldi     temp2, PWR_MAX_RPM1     ; higher than range1 power max ?
00015f 1701                      cp      temp1, temp2
000160 f060                      brcs    set_new_duty40          ; on carry - not higher, no restriction
000161 2f01                      mov     temp1, temp2            ; low (range1) RPM - set PWR_MAX_RPM1
000162 c00a                      rjmp    set_new_duty40          ; higher as range1
000163 3410      set_new_duty20: cpi     temp2, PWR_RANGE2*CLK_SCALE; lower range2 ?
000164 f038                      brcs    set_new_duty30          ; on carry - not lower, no restriction
000165 7f9e      set_new_duty22: cbr     flags2, (1<<RPM_RANGE1)
000166 6092                      sbr     flags2, (1<<RPM_RANGE2)
000167 e614                      ldi     temp2, PWR_MAX_RPM2     ; higher than range2 power max ?
000168 1701                      cp      temp1, temp2
000169 f018                      brcs    set_new_duty40          ; on carry - not higher, no restriction
00016a 2f01                      mov     temp1, temp2            ; low (range2) RPM - set PWR_MAX_RPM2
00016b c001                      rjmp    set_new_duty40          ; higher as range2
00016c 7f9c      set_new_duty30: cbr     flags2, (1<<RPM_RANGE1)+(1<<RPM_RANGE2)  ; range limits are evaluated - look for STARTUP conditions
00016d ff95      set_new_duty40: sbrs    flags2, STARTUP
00016e c009                      rjmp    set_new_duty50
00016f e02a                      ldi     temp3, PWR_STARTUP      ; at least PWR_STARTUP ?
000170 1702                      cp      temp1, temp3
000171 f410                      brcc    set_new_duty42          ; on no carry - higher than PWR_STARTUP, test PWR_MAX_STARTUP
000172 e00a                      ldi     temp1, PWR_STARTUP      ; lower - set to PWR_STARTUP
000173 c004                      rjmp    set_new_duty50
000174 e128      set_new_duty42: ldi     temp3, PWR_MAX_STARTUP  ; limit power in startup phase
000175 1702                      cp      temp1, temp3
000176 f008                      brcs    set_new_duty50          ; on carry - not higher, test range 2
000177 2f02                      mov     temp1, temp3            ; set PWR_MAX_STARTUP limit
000178 9500      set_new_duty50: com     temp1                   ; down-count to up-count (T0)
000179 94f8                      cli 
00017a dfc5                      rcall   eval_power_state        ; evaluate power state
00017b dfbd                      rcall   set_pwm                 ; set new PWM
00017c 9478                      sei
00017d 9508                      ret
                 ;-----bko-----------------------------------------------------------------
00017e 7b8f      evaluate_rpm:   cbr     flags1, (1<<EVAL_RPM)
00017f 9120 006c                 lds     temp3, rpm_x
000181 9110 006b                 lds     temp2, rpm_h
                 
000183 9100 006a                 lds     temp1, rpm_l    ; subtract 1/256
000185 1b01                      sub     temp1, temp2
000186 9300 006a                 sts     rpm_l, temp1
000188 9100 006b                 lds     temp1, rpm_h
00018a 0b02                      sbc     temp1, temp3
00018b 9300 006b                 sts     rpm_h, temp1
00018d 9100 006c                 lds     temp1, rpm_x
00018f 4000                      sbci    temp1, 0
000190 9300 006c                 sts     rpm_x, temp1
                 
000192 9120 0069                 lds     temp3, timing_acc_x
000194 9110 0068                 lds     temp2, timing_acc_h
000196 9100 0067                 lds     temp1, timing_acc_l
000198 9526                      lsr     temp3           ; make one complete commutation cycle
000199 9517                      ror     temp2
00019a 9507                      ror     temp1
00019b 9526                      lsr     temp3
00019c 9517                      ror     temp2
00019d 9507                      ror     temp1
                         ; temp3 is zero now - for sure !!
00019e 9320 0069                 sts     timing_acc_x, temp3
0001a0 9320 0068                 sts     timing_acc_h, temp3
0001a2 9320 0067                 sts     timing_acc_l, temp3
                         ; and add the result as 1/256
0001a4 9120 006a                 lds     temp3, rpm_l
0001a6 0f20                      add     temp3, temp1
0001a7 9320 006a                 sts     rpm_l, temp3
0001a9 9120 006b                 lds     temp3, rpm_h
0001ab 1f21                      adc     temp3, temp2
0001ac 9320 006b                 sts     rpm_h, temp3
0001ae e000                      ldi     temp1, 0
0001af 9120 006c                 lds     temp3, rpm_x
0001b1 1f20                      adc     temp3, temp1
0001b2 9320 006c                 sts     rpm_x, temp3
                 
0001b4 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 set_all_timings:
0001b5 eec8                      ldi     YL, low  (timeoutSTART)
0001b6 efdd                      ldi     YH, high (timeoutSTART)
0001b7 93c0 0071                 sts     wt_OCT1_tot_l, YL
0001b9 93d0 0072                 sts     wt_OCT1_tot_h, YH
0001bb ef2f                      ldi     temp3, 0xff
0001bc e13f                      ldi     temp4, 0x1f
0001bd 9320 006d                 sts     wt_comp_scan_l, temp3
0001bf 9330 006e                 sts     wt_comp_scan_h, temp4
0001c1 9320 006f                 sts     com_timing_l, temp3
0001c3 9330 0070                 sts     com_timing_h, temp4
                 set_timing_v:   
                 .if CLK_SCALE==1
                 .endif                
                 .if CLK_SCALE==2
0001c5 e0e3                      ldi     ZL, 0x03
                 .endif                
0001c6 93e0 0066                 sts     timing_x, ZL
0001c8 ef3f                      ldi     temp4, 0xff
0001c9 9330 0065                 sts     timing_h, temp4
0001cb ef2f                      ldi     temp3, 0xff
0001cc 9320 0064                 sts     timing_l, temp3
                 
0001ce 9508                      ret
                 ;-----bko-----------------------------------------------------------------
0001cf df37      update_timing:  rcall   tcnt1_to_temp
0001d0 9300 0060                 sts     tcnt1_sav_l, temp1
0001d2 9310 0061                 sts     tcnt1_sav_h, temp2
0001d4 0f0c                      add     temp1, YL
0001d5 1f1d                      adc     temp2, YH
0001d6 e035                      ldi     temp4, (1<<TOIE1)+(1<<TOIE0)
0001d7 bf39                      out     TIMSK, temp4
0001d8 bd1b                      out     OCR1AH, temp2
0001d9 bd0a                      out     OCR1AL, temp1
0001da 6071                      sbr     flags0, (1<<OCT1_PENDING)
0001db e135                      ldi     temp4, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; enable interrupt again
0001dc bf39                      out     TIMSK, temp4
0001dd e830
0001de bf3b                      enable_input
                 
                         ; calculate next waiting times - timing(-l-h-x) holds the time of 4 commutations
0001df 9100 0064                 lds     temp1, timing_l
0001e1 9110 0065                 lds     temp2, timing_h
0001e3 91e0 0066                 lds     ZL, timing_x
                 
0001e5 9300 0073                 sts     zero_wt_l, temp1        ; save for zero crossing timeout
0001e7 9310 0074                 sts     zero_wt_h, temp2
0001e9 23ee                      tst     ZL
0001ea f029                      breq    update_t00
0001eb ef3f                      ldi     temp4, 0xff
0001ec 9330 0073                 sts     zero_wt_l, temp4        ; save for zero crossing timeout
0001ee 9330 0074                 sts     zero_wt_h, temp4
                 update_t00:
0001f0 95e6                      lsr     ZL                      ; build a quarter
0001f1 9517                      ror     temp2
0001f2 9507                      ror     temp1
                 
0001f3 95e6                      lsr     ZL
0001f4 9517                      ror     temp2
0001f5 9507                      ror     temp1
0001f6 9120 0064                 lds     temp3, timing_l         ; .. and subtract from timing
0001f8 9130 0065                 lds     temp4, timing_h
0001fa 91e0 0066                 lds     ZL, timing_x
0001fc 1b20                      sub     temp3, temp1
0001fd 0b31                      sbc     temp4, temp2
0001fe 40e0                      sbci    ZL, 0
                 
0001ff 9100 0060                 lds     temp1, tcnt1_sav_l      ; calculate this commutation time
000201 9110 0061                 lds     temp2, tcnt1_sav_h
000203 91c0 0062                 lds     YL, last_tcnt1_l
000205 91d0 0063                 lds     YH, last_tcnt1_h
000207 9300 0062                 sts     last_tcnt1_l, temp1
000209 9310 0063                 sts     last_tcnt1_h, temp2
00020b 1b0c                      sub     temp1, YL
00020c 0b1d                      sbc     temp2, YH
00020d 9300 0075                 sts     last_com_l, temp1
00020f 9310 0076                 sts     last_com_h, temp2
                 
000211 0f20                      add     temp3, temp1            ; .. and add to timing
000212 1f31                      adc     temp4, temp2
000213 e010                      ldi     temp2, 0
000214 1fe1                      adc     ZL, temp2
                 
                         ; limit RPM to 120.000
000215 23ee                      tst     ZL
000216 f441                      brne    update_t90
000217 2333                      tst     temp4
000218 f021                      breq    update_t10
000219 3032                      cpi     temp4, 0x01*CLK_SCALE
00021a f421                      brne    update_t90
00021b 3928                      cpi     temp3, 0x4c*CLK_SCALE   ; 120.000 RPM
00021c f410                      brcc    update_t90
                         ; set RPM to 120.000
                 
                 update_t10:
00021d e604                      ldi     temp1, PWR_MAX_RPM2
00021e 2ed0                      mov     sys_control, temp1
                 
                 ;update_t10:    ldi     temp4, 0x01*CLK_SCALE
                 ;               ldi     temp3, 0x4c*CLK_SCALE
                 ;               tst     run_control 
                 ;               brne    update_t90              ; just active
                 ;               ldi     temp1, 0xff             ; not active - reactivate
                 ;               mov     run_control, temp1
                 
00021f 9320 0064 update_t90:     sts     timing_l, temp3
000221 9330 0065                 sts     timing_h, temp4
000223 93e0 0066                 sts     timing_x, ZL
                 .if CLK_SCALE==1
                 .endif                
                 .if CLK_SCALE==2                                
000225 30e4                      cpi     ZL, 0x04                ; limit range to 0x3ffff
                 .endif                
000226 f008                      brcs    update_t99
000227 df9d                      rcall   set_timing_v
                 
000228 9100 0067 update_t99:     lds     temp1, timing_acc_l
00022a 0f02                      add     temp1, temp3
00022b 9300 0067                 sts     timing_acc_l, temp1
00022d 9100 0068                 lds     temp1, timing_acc_h
00022f 1f03                      adc     temp1, temp4
000230 9300 0068                 sts     timing_acc_h, temp1
000232 9100 0069                 lds     temp1, timing_acc_x
000234 1f0e                      adc     temp1, ZL
000235 9300 0069                 sts     timing_acc_x, temp1
                 
000237 95e6                      lsr     ZL                      ; a 16th is the next wait before scan
000238 9537                      ror     temp4
000239 9527                      ror     temp3
00023a 95e6                      lsr     ZL
00023b 9537                      ror     temp4
00023c 9527                      ror     temp3
00023d 95e6                      lsr     ZL
00023e 9537                      ror     temp4
00023f 9527                      ror     temp3
000240 95e6                      lsr     ZL
000241 9537                      ror     temp4
000242 9527                      ror     temp3
000243 9320 006d                 sts     wt_comp_scan_l, temp3
000245 9330 006e                 sts     wt_comp_scan_h, temp4
                 
                         ; use the same value for commutation timing (15-)
000247 9320 006f                 sts     com_timing_l, temp3
000249 9330 0070                 sts     com_timing_h, temp4
                 
00024b 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 calc_next_timing:
00024c 91c0 006d                 lds     YL, wt_comp_scan_l      ; holds wait-before-scan value
00024e 91d0 006e                 lds     YH, wt_comp_scan_h
000250 df7e                      rcall   update_timing
                 
000251 9508                      ret
                 
000252 fd70      wait_OCT1_tot:  sbrc    flags0, OCT1_PENDING
000253 cffe                      rjmp    wait_OCT1_tot
                 
000254 9837
000255 b700
000256 6008
000257 bf00      set_OCT1_tot:   AcInit
                 
000258 91d0 0074                 lds     YH, zero_wt_h
00025a 91c0 0073                 lds     YL, zero_wt_l
00025c deaa                      rcall   tcnt1_to_temp
00025d 0f0c                      add     temp1, YL
00025e 1f1d                      adc     temp2, YH
00025f e035                      ldi     temp4, (1<<TOIE1)+(1<<TOIE0)
000260 bf39                      out     TIMSK, temp4
000261 bd1b                      out     OCR1AH, temp2
000262 bd0a                      out     OCR1AL, temp1
000263 6071                      sbr     flags0, (1<<OCT1_PENDING)
000264 e135                      ldi     temp4, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
000265 bf39                      out     TIMSK, temp4
000266 e830
000267 bf3b                      enable_input
000268 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 wait_OCT1_before_switch:
000269 de9d                      rcall   tcnt1_to_temp
00026a 91c0 006f                 lds     YL, com_timing_l
00026c 91d0 0070                 lds     YH, com_timing_h
00026e 0f0c                      add     temp1, YL
00026f 1f1d                      adc     temp2, YH
000270 e025                      ldi     temp3, (1<<TOIE1)+(1<<TOIE0)
000271 bf29                      out     TIMSK, temp3
000272 bd1b                      out     OCR1AH, temp2
000273 bd0a                      out     OCR1AL, temp1
000274 6071                      sbr     flags0, (1<<OCT1_PENDING)
000275 e125                      ldi     temp3, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
000276 bf29                      out     TIMSK, temp3
000277 e830
000278 bf3b                      enable_input
                 
                         ; don't waste time while waiting - do some controls, if indicated
000279 fd84                      sbrc    flags1, EVAL_RC_PULS
00027a de95                      rcall   evaluate_rc_puls
00027b fd85                      sbrc    flags1, EVAL_SYS_STATE
00027c deac                      rcall   evaluate_sys_state
                 
00027d fd87                      sbrc    flags1, EVAL_PWM
00027e decd                      rcall   set_new_duty
                 
00027f fd86                      sbrc    flags1, EVAL_RPM
000280 defd                      rcall   evaluate_rpm
                 
000281 fd70      OCT1_wait:      sbrc    flags0, OCT1_PENDING
000282 cffe                      rjmp    OCT1_wait
000283 9508                      ret
                 ;-----bko-----------------------------------------------------------------
000284 91c0 0071 start_timeout:  lds     YL, wt_OCT1_tot_l
000286 91d0 0072                 lds     YH, wt_OCT1_tot_h
000288 df46                      rcall   update_timing
                 
000289 b50c                      in      temp1, TCNT1L
00028a 700f                      andi    temp1, 0x0f
00028b 1bd0                      sub     YH, temp1
00028c 3bdb                      cpi     YH, high (timeoutMIN)
00028d f408                      brcc    set_tot2
00028e efdd                      ldi     YH, high (timeoutSTART)         
                 set_tot2:
00028f 93d0 0072                 sts     wt_OCT1_tot_h, YH
                 
000291 d018                      rcall   sync_with_poweron       ; wait at least 100+ microseconds
000292 d017                      rcall   sync_with_poweron       ; for demagnetisation - one sync may be added
                 
000293 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 switch_power_off:
000294 e0f5                      ldi     ZH, MIN_DUTY-1          ; ZH is new_duty
000295 930f
000296 e005
000297 9500
000298 dea0
000299 910f                      SetPWMi(MIN_DUTY-1)
                 
00029a e000                      ldi     temp1, 0                ; reset limiter
00029b 2ed0                      mov     sys_control, temp1
                 
00029c e00e                      ldi     temp1, INIT_PB          ; all off
00029d bb08                      out     PORTB, temp1
00029e e000                      ldi     temp1, INIT_PC          ; all off
00029f bb05                      out     PORTC, temp1
0002a0 e004                      ldi     temp1, INIT_PD          ; all off
0002a1 bb02                      out     PORTD, temp1
                 
0002a2 6081                      sbr     flags1, (1<<POWER_OFF)  ; disable power on
0002a3 7f97                      cbr     flags2, (1<<POFF_CYCLE)
0002a4 6290                      sbr     flags2, (1<<STARTUP)
0002a5 9508                      ret                             ; motor is off
                 ;-----bko-----------------------------------------------------------------
0002a6 e008      wait_if_spike:  ldi     temp1, 4*CLK_SCALE
0002a7 950a      wait_if_spike2: dec     temp1
0002a8 f7f1                      brne    wait_if_spike2
0002a9 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 sync_with_poweron:
0002aa fd76                      sbrc    flags0, I_OFF_CYCLE     ; first wait for power on
0002ab cffe                      rjmp    sync_with_poweron
                 wait_for_poweroff:
0002ac ff76                      sbrs    flags0, I_OFF_CYCLE     ; now wait for power off
0002ad cffe                      rjmp    wait_for_poweroff
0002ae 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 motor_brake:
                 #ifdef MOT_BRAKE
                 #endif
0002af 9508                      ret
                 
                 
                 wait64ms:
0002b0 e002                      ldi     temp1, 1*CLK_SCALE
0002b1 2ee0                      mov     t1_timeout, temp1
                 wait120ms_wait_for_t1:    
0002b2 20ee                      tst     t1_timeout
0002b3 f7f1                      brne    wait120ms_wait_for_t1
0002b4 9508                      ret
                 
0002b5 e00e      pre_align:      ldi     temp1, INIT_PB  ; all off
0002b6 bb08                      out     PORTB, temp1
0002b7 e004                      ldi     temp1, INIT_PD  ; all off
0002b8 bb02                      out     PORTD, temp1
0002b9 e000                      ldi     temp1, INIT_PC  ; all off
0002ba bb05                      out     PORTC, temp1
0002bb e208                      ldi     temp1, 20*CLK_SCALE
0002bc 950a      pp_FETs_off_wt: dec     temp1
0002bd f7f1                      brne    pp_FETs_off_wt
0002be 7f8e                      cbr     flags1, (1<<POWER_OFF)  ; enable power
0002bf e00a                      ldi     temp1, PWR_STARTUP      ; set limiter
0002c0 2ed0                      mov     sys_control, temp1
0002c1 930f
0002c2 e002
0002c3 9500
0002c4 de74
0002c5 910f                      SetPWMi(PWR_STARTUP*1/4);
0002c6 d16d                      rcall   com5com6
0002c7 d172                      rcall   com6com1
0002c8 dfe7                      rcall   wait64ms
0002c9 dfe6                      rcall   wait64ms
0002ca 930f
0002cb e005
0002cc 9500
0002cd de6b
0002ce 910f                      SetPWMi(PWR_STARTUP*2/4);
0002cf dfe0                      rcall   wait64ms
0002d0 930f
0002d1 e007
0002d2 9500
0002d3 de65
0002d4 910f                      SetPWMi(PWR_STARTUP*3/4);
0002d5 dfda                      rcall   wait64ms
0002d6 930f
0002d7 e00a
0002d8 9500
0002d9 de5f
0002da 910f                      SetPWMi(PWR_STARTUP);               
0002db 9508                      ret                
                 ;-----bko-----------------------------------------------------------------
                 ; **** startup loop ****
0002dc dfb7      init_startup:   rcall   switch_power_off
0002dd dfd1                      rcall   motor_brake
                 wait_for_power_on:
0002de 9a92                      DbgLEDOn
                 
0002df de30                      rcall   evaluate_rc_puls
0002e0 30f7                      cpi     ZH, MIN_DUTY + 1
0002e1 f3e0                      brcs    wait_for_power_on
0002e2 9837
0002e3 b700
0002e4 6008
0002e5 bf00                      AcInit
0002e6 dfce                      rcall   pre_align
                 
0002e7 9a92                      DbgLEDOn
                 
0002e8 7f9b                      cbr     flags2, (1<<SCAN_TIMEOUT)
0002e9 e000                      ldi     temp1, 0
0002ea 9300 007c                 sts     goodies, temp1
0002ec e500                      ldi     temp1, 40*CLK_SCALE; x 32msec
0002ed 2ee0                      mov     t1_timeout, temp1
0002ee dec6                      rcall   set_all_timings
0002ef df94                      rcall   start_timeout
                 ;-----bko-----------------------------------------------------------------
                 ; **** start control loop ****
                 
                 ; state 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
0002f0 ff94      start1:         sbrs    flags2, COMP_SAVE       ; high ?
0002f1 c010                      rjmp    start1_2                ; .. no - loop, while high
                 
0002f2 fd70      start1_0:       sbrc    flags0, OCT1_PENDING
0002f3 c002                      rjmp    start1_1
0002f4 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
0002f5 c013                      rjmp    start1_9
0002f6 dfb3      start1_1:       rcall   sync_with_poweron
                 
0002f7 fd94                      sbrc    flags2, COMP_SAVE       ; high ?
0002f8 cff9                      rjmp    start1_0                ; .. no - loop, while high
                 
                 ; do the special 120- switch
0002f9 e000                      ldi     temp1, 0
0002fa 9300 007c                 sts     goodies, temp1
0002fc d109                      rcall   com1com2
0002fd d10e                      rcall   com2com3
0002fe d11e                      rcall   com3com4
0002ff de10                      rcall   evaluate_rc_puls
000300 df83                      rcall   start_timeout
000301 c031                      rjmp    start4
                         
000302 fd70      start1_2:       sbrc    flags0, OCT1_PENDING
000303 c002                      rjmp    start1_3
000304 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000305 c003                      rjmp    start1_9
000306 dfa3      start1_3:       rcall   sync_with_poweron
000307 ff94                      sbrs    flags2, COMP_SAVE       ; high ?
000308 cff9                      rjmp    start1_2                ; .. no - loop, while low
                 
                 start1_9:
000309 d0fc                      rcall   com1com2
00030a df79                      rcall   start_timeout
                 
                 ; state 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
                 
00030b fd94      start2:         sbrc    flags2, COMP_SAVE
00030c c008                      rjmp    start2_2
                 
00030d fd70      start2_0:       sbrc    flags0, OCT1_PENDING
00030e c002                      rjmp    start2_1
00030f 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000310 c00b                      rjmp    start2_9
000311 df98      start2_1:       rcall   sync_with_poweron
000312 ff94                      sbrs    flags2, COMP_SAVE
000313 cff9                      rjmp    start2_0
000314 c007                      rjmp    start2_9
                 
000315 fd70      start2_2:       sbrc    flags0, OCT1_PENDING
000316 c002                      rjmp    start2_3
000317 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000318 c003                      rjmp    start2_9
000319 df90      start2_3:       rcall   sync_with_poweron
00031a fd94                      sbrc    flags2, COMP_SAVE
00031b cff9                      rjmp    start2_2
                 
                 start2_9:
00031c d0ef                      rcall   com2com3
00031d ddf2                      rcall   evaluate_rc_puls
00031e df65                      rcall   start_timeout
                 
                 ; state 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 
00031f ff94      start3:         sbrs    flags2, COMP_SAVE
000320 c008                      rjmp    start3_2
                 
000321 fd70      start3_0:       sbrc    flags0, OCT1_PENDING
000322 c002                      rjmp    start3_1
000323 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000324 c00b                      rjmp    start3_9
000325 df84      start3_1:       rcall   sync_with_poweron
000326 fd94                      sbrc    flags2, COMP_SAVE
000327 cff9                      rjmp    start3_0
000328 c007                      rjmp    start3_9
                 
000329 fd70      start3_2:       sbrc    flags0, OCT1_PENDING
00032a c002                      rjmp    start3_3
00032b 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
00032c c003                      rjmp    start3_9
00032d df7c      start3_3:       rcall   sync_with_poweron
00032e ff94                      sbrs    flags2, COMP_SAVE
00032f cff9                      rjmp    start3_2
                 
                 start3_9:
000330 d0ec                      rcall   com3com4
000331 de1a                      rcall   set_new_duty
000332 df51                      rcall   start_timeout
                 
                 ; state 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
                 
000333 fd94      start4:         sbrc    flags2, COMP_SAVE
000334 c008                      rjmp    start4_2
                 
000335 fd70      start4_0:       sbrc    flags0, OCT1_PENDING
000336 c002                      rjmp    start4_1
000337 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000338 c00b                      rjmp    start4_9
000339 df70      start4_1:       rcall   sync_with_poweron
00033a ff94                      sbrs    flags2, COMP_SAVE
00033b cff9                      rjmp    start4_0
00033c c007                      rjmp    start4_9
                 
00033d fd70      start4_2:       sbrc    flags0, OCT1_PENDING
00033e c002                      rjmp    start4_3
00033f 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000340 c003                      rjmp    start4_9
000341 df68      start4_3:       rcall   sync_with_poweron
000342 fd94                      sbrc    flags2, COMP_SAVE
000343 cff9                      rjmp    start4_2
                 
                 start4_9:
000344 d0de                      rcall   com4com5
000345 df3e                      rcall   start_timeout
                 
                 
                 ; state 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
                 
                 
000346 ff94      start5:         sbrs    flags2, COMP_SAVE
000347 c008                      rjmp    start5_2
                 
000348 fd70      start5_0:       sbrc    flags0, OCT1_PENDING
000349 c002                      rjmp    start5_1
00034a 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
00034b c00b                      rjmp    start5_9
00034c df5d      start5_1:       rcall   sync_with_poweron
00034d fd94                      sbrc    flags2, COMP_SAVE
00034e cff9                      rjmp    start5_0
00034f c007                      rjmp    start5_9
                 
000350 fd70      start5_2:       sbrc    flags0, OCT1_PENDING
000351 c002                      rjmp    start5_3
000352 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000353 c003                      rjmp    start5_9
000354 df55      start5_3:       rcall   sync_with_poweron
000355 ff94                      sbrs    flags2, COMP_SAVE
000356 cff9                      rjmp    start5_2
                 
                 start5_9:
000357 d0dc                      rcall   com5com6
000358 ddd0                      rcall   evaluate_sys_state
000359 df2a                      rcall   start_timeout
                 
                 ; state 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
                 
00035a fd94      start6:         sbrc    flags2, COMP_SAVE
00035b c008                      rjmp    start6_2
                 
00035c fd70      start6_0:       sbrc    flags0, OCT1_PENDING
00035d c002                      rjmp    start6_1
00035e 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
00035f c00b                      rjmp    start6_9
000360 df49      start6_1:       rcall   sync_with_poweron
000361 ff94                      sbrs    flags2, COMP_SAVE
000362 cff9                      rjmp    start6_0
000363 c007                      rjmp    start6_9
                 
000364 fd70      start6_2:       sbrc    flags0, OCT1_PENDING
000365 c002                      rjmp    start6_3
000366 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000367 c003                      rjmp    start6_9
000368 df41      start6_3:       rcall   sync_with_poweron
000369 fd94                      sbrc    flags2, COMP_SAVE
00036a cff9                      rjmp    start6_2
                 
                 start6_9:
00036b d0ce                      rcall   com6com1
                 
00036c 2d02                      mov     temp1, tcnt0_power_on
00036d 3f0a                      cpi     temp1, NO_POWER
00036e f409                      brne    s6_power_ok
00036f cf6c                      rjmp    init_startup
                 
000370 20ee      s6_power_ok:    tst     t1_timeout
000371 f409                      brne    s6_test_rpm
000372 cf69                      rjmp    init_startup            ;-) demich
                                 
000373 9100 0066 s6_test_rpm:    lds     temp1, timing_x
000375 2300                      tst     temp1
000376 f421                      brne    s6_goodies
000377 9100 0065                 lds     temp1, timing_h         ; get actual RPM reference high
                 ;               cpi     temp1, PWR_RANGE1*CLK_SCALE
000379 3400                      cpi     temp1, PWR_RANGE2*CLK_SCALE
00037a f050                      brcs    s6_run1
                 
00037b 9100 007c s6_goodies:     lds     temp1, goodies
00037d fd92                      sbrc    flags2, SCAN_TIMEOUT
00037e 2700                      clr     temp1
00037f 9503                      inc     temp1
000380 9300 007c                 sts     goodies,  temp1
000382 7f9b                      cbr     flags2, (1<<SCAN_TIMEOUT)
000383 330c                      cpi     temp1, ENOUGH_GOODIES
000384 f038                      brcs    s6_start1       
                 
000385 ef0f      s6_run1:        ldi     temp1, 0xff
000386 2ef0                      mov     run_control, temp1
                 
000387 dec4                      rcall   calc_next_timing
000388 decb                      rcall   set_OCT1_tot
                 
000389 9892                      DbgLEDOff
                 
00038a 7d9f                      cbr     flags2, (1<<STARTUP)
00038b c002                      rjmp    run1                    ; running state begins
                 
00038c def7      s6_start1:      rcall   start_timeout           ; need to be here for a correct temp1=comp_state
00038d cf62                      rjmp    start1                  ; go back to state 1
                 
                 ;-----bko-----------------------------------------------------------------
                 ; **** running control loop ****
                 
                 ; run 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
                 
00038e d059      run1:           rcall   wait_for_low
00038f ff70                      sbrs    flags0, OCT1_PENDING
000390 c043                      rjmp    run_to_start
000391 d065                      rcall   wait_for_high
000392 ff70                      sbrs    flags0, OCT1_PENDING
000393 c040                      rjmp    run_to_start
000394 6480                      sbr     flags1, (1<<EVAL_RPM)
000395 ded3                      rcall   wait_OCT1_before_switch
000396 d06f                      rcall   com1com2
000397 deb4                      rcall   calc_next_timing
000398 deb9                      rcall   wait_OCT1_tot
                                 
                 ; run 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
                 
000399 d05d      run2:           rcall   wait_for_high
00039a ff70                      sbrs    flags0, OCT1_PENDING
00039b c038                      rjmp    run_to_start
00039c d04b                      rcall   wait_for_low
00039d ff70                      sbrs    flags0, OCT1_PENDING
00039e c035                      rjmp    run_to_start
00039f 6180                      sbr     flags1, (1<<EVAL_RC_PULS)
0003a0 dec8                      rcall   wait_OCT1_before_switch
0003a1 d06a                      rcall   com2com3
0003a2 dea9                      rcall   calc_next_timing
0003a3 deae                      rcall   wait_OCT1_tot
                 
                 ; run 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 
0003a4 d043      run3:           rcall   wait_for_low
0003a5 ff70                      sbrs    flags0, OCT1_PENDING
0003a6 c02d                      rjmp    run_to_start
0003a7 d04f                      rcall   wait_for_high
0003a8 ff70                      sbrs    flags0, OCT1_PENDING
0003a9 c02a                      rjmp    run_to_start
0003aa 6880                      sbr     flags1, (1<<EVAL_PWM)
0003ab debd                      rcall   wait_OCT1_before_switch
0003ac d070                      rcall   com3com4
0003ad de9e                      rcall   calc_next_timing
0003ae dea3                      rcall   wait_OCT1_tot
                 
                 ; run 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
0003af d047      run4:           rcall   wait_for_high
0003b0 ff70                      sbrs    flags0, OCT1_PENDING
0003b1 c022                      rjmp    run_to_start
0003b2 d035                      rcall   wait_for_low
0003b3 ff70                      sbrs    flags0, OCT1_PENDING
0003b4 c01f                      rjmp    run_to_start
0003b5 deb3                      rcall   wait_OCT1_before_switch
0003b6 d06c                      rcall   com4com5
0003b7 de94                      rcall   calc_next_timing
0003b8 de99                      rcall   wait_OCT1_tot
                 
                 ; run 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
                 
0003b9 d02e      run5:           rcall   wait_for_low
0003ba ff70                      sbrs    flags0, OCT1_PENDING
0003bb c018                      rjmp    run_to_start
0003bc d03a                      rcall   wait_for_high
0003bd ff70                      sbrs    flags0, OCT1_PENDING
0003be c015                      rjmp    run_to_start
0003bf 6280                      sbr     flags1, (1<<EVAL_SYS_STATE)
0003c0 dea8                      rcall   wait_OCT1_before_switch
0003c1 d072                      rcall   com5com6
0003c2 de89                      rcall   calc_next_timing
0003c3 de8e                      rcall   wait_OCT1_tot
                 
                 ; run 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
                 
0003c4 d032      run6:           rcall   wait_for_high
0003c5 ff70                      sbrs    flags0, OCT1_PENDING
0003c6 c00d                      rjmp    run_to_start
0003c7 d020                      rcall   wait_for_low
0003c8 ff70                      sbrs    flags0, OCT1_PENDING
0003c9 c00a                      rjmp    run_to_start
0003ca de9e                      rcall   wait_OCT1_before_switch
0003cb d06e                      rcall   com6com1
0003cc de7f                      rcall   calc_next_timing
0003cd de84                      rcall   wait_OCT1_tot
                 
                 ;               rjmp    run6_2
                 
0003ce 9100 0066                 lds     temp1, timing_x
0003d0 2300                      tst     temp1
0003d1 f039                      breq    run6_2                  ; higher than 610 RPM if zero
                 .if CLK_SCALE==2                                
0003d2 950a                      dec     temp1
0003d3 f029                      breq    run6_2                  ; higher than 610 RPM if equ 1
                 .endif                
0003d4 6290      run_to_start:   sbr     flags2, (1<<STARTUP)
0003d5 7f97                      cbr     flags2, (1<<POFF_CYCLE)
0003d6 ff80                      sbrs    flags1, POWER_OFF
0003d7 c00d                      rjmp    restart_control
0003d8 cf05                      rjmp    wait_for_power_on
                 
0003d9 7f97      run6_2:         cbr     flags2, (1<<POFF_CYCLE)
0003da 20ff                      tst     run_control             ; only once !
0003db f041                      breq    run6_9
0003dc 94fa                      dec     run_control
0003dd f029                      breq    run6_3                  ; poweroff if 0
0003de 2d0f                      mov     temp1, run_control
0003df 3001                      cpi     temp1, 1                ; poweroff if 1
0003e0 f011                      breq    run6_3
0003e1 3002                      cpi     temp1, 2                ; poweroff if 2
0003e2 f409                      brne    run6_9
0003e3 6098      run6_3:         sbr     flags2, (1<<POFF_CYCLE)
                 
                 run6_9:
0003e4 cfa9                      rjmp    run1                    ; go back to run 1
                 
                 restart_control:
0003e5 94f8                      cli                             ; disable all interrupts
0003e6 dead                      rcall   switch_power_off
0003e7 cc35                      rjmp    reset
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; *** scan comparator utilities ***
                 .macro __wait_for_filter
                                 clc
                                 sbis    ACSR, ACO
                                 sec
                                 brcc    wait_for_filter_1
                                 inc     temp2
                 wait_for_filter_1:
                                 rol     temp1
                                 brcc    wait_for_filter_2
                                 dec     temp2
                 wait_for_filter_2:
                 .endmacro
                                                 
                 wait_for_low:   
0003e8 ef0f                      ldi     temp1, 0xFF
0003e9 e018                      ldi     temp2, 8
                 wait_for_low_loop:
0003ea ff70                      sbrs    flags0, OCT1_PENDING
0003eb 9508                      ret
0003ec 9488
0003ed 9b45
0003ee 9408
0003ef f408
0003f0 9513
0003f1 1f00
0003f2 f408
0003f3 951a                      __wait_for_filter
0003f4 3012                      cpi     temp2, (8-7) + 1
0003f5 f7a0                      brcc    wait_for_low_loop
0003f6 9508                      ret
                                                
                 wait_for_high:   
0003f7 e000                      ldi     temp1, 0x0
0003f8 e010                      ldi     temp2, 0
                 wait_for_high_loop:
0003f9 ff70                      sbrs    flags0, OCT1_PENDING
0003fa 9508                      ret
0003fb 9488
0003fc 9b45
0003fd 9408
0003fe f408
0003ff 9513
000400 1f00
000401 f408
000402 951a                      __wait_for_filter
000403 3017                      cpi     temp2, 7
000404 f3a0                      brcs    wait_for_high_loop
000405 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 ; *** commutation utilities ***
000406 9ac2      com1com2:       BpFET_off                             ; Bp off
000407 ff80                      sbrs    flags1, POWER_OFF
000408 98c3                      ApFET_on                              ; Ap on
000409 e004
00040a b907                      AcPhaseB
00040b 9508                      ret
                 
00040c e104      com2com3:       ldi     temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
00040d bf09                      out     TIMSK, temp1                  ;  .. only ONE should change these values at the time
00040e 0000                      nop
00040f 7d7f                      cbr     flags0, (1<<A_FET)            ; next nFET = BnFET
000410 7e7f                      cbr     flags0, (1<<C_FET)
000411 fd81                      sbrc    flags1, FULL_POWER
000412 c002                      rjmp    c2_switch
000413 fd76                      sbrc    flags0, I_OFF_CYCLE           ; was power off ?
000414 c003                      rjmp    c2_done                       ; .. yes - futhermore work is done in timer0 interrupt
000415 98aa      c2_switch:      CnFET_off                             ; Cn off
000416 ff80                      sbrs    flags1, POWER_OFF
000417 9aa9                      BnFET_on                              ; Bn on
000418 e105      c2_done:        ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
000419 bf09                      out     TIMSK, temp1
00041a e005
00041b b907                      AcPhaseC
00041c 9508                      ret
                 
00041d 9ac3      com3com4:       ApFET_off                             ; Ap off
00041e ff80                      sbrs    flags1, POWER_OFF
00041f 98c1                      CpFET_on                              ; Cp on
000420 e003
000421 b907                      AcPhaseA
000422 9508                      ret
                 
000423 e104      com4com5:       ldi     temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
000424 bf09                      out     TIMSK, temp1                  ;  .. only ONE should change these values at the time
000425 0000                      nop
000426 6270                      sbr     flags0, (1<<A_FET)            ; next nFET = AnFET
000427 7e7f                      cbr     flags0, (1<<C_FET)
000428 fd81                      sbrc    flags1, FULL_POWER
000429 c002                      rjmp    c4_switch
00042a fd76                      sbrc    flags0, I_OFF_CYCLE           ; was power off ?
00042b c003                      rjmp    c4_done                       ; .. yes - futhermore work is done in timer0 interrupt
00042c 98a9      c4_switch:      BnFET_off                             ; Bn off
00042d ff80                      sbrs    flags1, POWER_OFF
00042e 9aa8                      AnFET_on                              ; An on
00042f e105      c4_done:        ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
000430 bf09                      out     TIMSK, temp1
000431 e004
000432 b907                      AcPhaseB
000433 9508                      ret
                 
000434 9ac1      com5com6:       CpFET_off                             ; Cp off
000435 ff80                      sbrs    flags1, POWER_OFF
000436 98c2                      BpFET_on                              ; Bp on
000437 e005
000438 b907                      AcPhaseC
000439 9508                      ret
                 
00043a e104      com6com1:       ldi     temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
00043b bf09                      out     TIMSK, temp1                  ;  .. only ONE should change these values at the time
00043c 0000                      nop
00043d 7d7f                      cbr     flags0, (1<<A_FET)            ; next nFET = CnFET
00043e 6170                      sbr     flags0, (1<<C_FET)
00043f fd81                      sbrc    flags1, FULL_POWER
000440 c002                      rjmp    c6_switch
000441 fd76                      sbrc    flags0, I_OFF_CYCLE           ; was power off ?
000442 c003                      rjmp    c6_done                       ; .. yes - futhermore work is done in timer0 interrupt
000443 98a8      c6_switch:      AnFET_off                             ; An off
000444 ff80                      sbrs    flags1, POWER_OFF
000445 9aaa                      CnFET_on                              ; Cn on
000446 e105      c6_done:        ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
000447 bf09                      out     TIMSK, temp1
000448 e003
000449 b907                      AcPhaseA
00044a 9508                      ret
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega8 register use summary:
r0 :   0 r1 :   9 r2 :   4 r3 :   0 r4 :   0 r5 :   0 r6 :   3 r7 :   2 
r8 :   2 r9 :   0 r10:   0 r11:   6 r12:   5 r13:   6 r14:   6 r15:   4 
r16: 232 r17:  66 r18:  54 r19:  48 r20:  16 r21:   7 r22:   8 r23:  53 
r24:  36 r25:  50 r26:   2 r27:   1 r28:  11 r29:  15 r30:  17 r31:   5 
x  :   1 y  :   0 z  :   0 
Registers used: 27 out of 35 (77.1%)

ATmega8 instruction use summary:
adc   :   9 add   :   6 adiw  :   0 and   :   0 andi  :   1 asr   :   0 
bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 brcc  :  11 brcs  :  12 
breq  :  13 brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 
brlo  :   3 brlt  :   0 brmi  :   0 brne  :  22 brpl  :   0 brsh  :   3 
brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 bst   :   0 
cbi   :  14 cbr   :  25 clc   :   2 clh   :   0 cli   :   4 cln   :   0 
clr   :  13 cls   :   0 clt   :   0 clv   :   0 clz   :   0 com   :   8 
cp    :   6 cpc   :   2 cpi   :  27 cpse  :   0 dec   :  17 eor   :   0 
fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :  15 
inc   :   7 ld    :   0 ldd   :   0 ldi   : 104 lds   :  42 lpm   :   0 
lsl   :   0 lsr   :  11 mov   :  27 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   8 or    :   0 ori   :   0 out   :  65 
pop   :   6 push  :   6 rcall : 116 ret   :  32 reti  :  19 rjmp  : 110 
rol   :   2 ror   :  19 sbc   :   4 sbci  :   4 sbi   :  13 sbic  :   1 
sbis  :   3 sbiw  :   0 sbr   :  38 sbrc  :  38 sbrs  :  37 sec   :   2 
seh   :   0 sei   :   3 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   1 std   :   0 
sts   :  47 sub   :   5 subi  :   4 swap  :   0 tst   :  13 wdr   :   0 

Instructions used: 50 out of 108 (46.3%)

ATmega8 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000896   2178     20   2198    8192  26.8%
[.dseg] 0x000060 0x0000e3      0    131    131    1024  12.8%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
