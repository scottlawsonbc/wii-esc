
AVRASM ver. 2.1.12  core\bldc.asm Wed Sep 28 14:00:46 2011

[builtin](2): Including file 'core\..\input\pwm_rc_200.inc'
core\..\input\pwm_rc_200.inc(1): Including file 'core\ppm.inc'
[builtin](3): Including file 'core\..\hw\Mystery20A.inc'
core\..\hw\Mystery20A.inc(1): Including file 'core\common.inc'
core\bldc.asm(20): Including file 'C:\Program Files (x86)\AvrAssembler2\AppNotes\m8def.inc'
                 
                 ;**** **** **** **** ****
                 
                 
                 .equ    EXT0_EN    = 0x40       ; enable ext0int
                 
                 #define __ext_int0  rjmp ext_int0_isr
                 .macro __ext_int0_isr
                   __ext_micp_isr
                 .endmacro
                 
                 ;-----bko-----------------------------------------------------------------
                 ; external interrupt0 = rc pulse input
                 .macro __ext_micp_isr
                                 in      i_sreg, SREG
                 
                 ; evaluate edge of this interrupt
                                 in      i_temp1, MCUCR
                                 sbrs    i_temp1, ISC00
                                 rjmp    falling_edge                              ; bit is clear = falling edge
                 
                 ; should be rising edge - test rc impuls level state for possible jitter
                                 sbis    PIND, rcp_in
                                 rjmp    extint1_exit                              ; jump, if low state
                 
                 ; rc impuls is at high state
                                 ldi     i_temp1, (1<<ISC01)
                                 out     MCUCR, i_temp1                            ; set next int0 to falling edge
                 
                 ; get timer1 values
                                 in      i_temp1, TCNT1L
                                 in      i_temp2, TCNT1H
                                 mov     start_rcpuls_l, i_temp1
                                 mov     start_rcpuls_h, i_temp2
                 ; test rcpulse interval
                                 cbr     flags2, (1<<RC_INTERVAL_OK)               ; preset to not ok
                                 lds     i_temp3, stop_rcpuls_l
                                 sub     i_temp1, i_temp3
                                 lds     i_temp3, stop_rcpuls_h
                                 sbc     i_temp2, i_temp3
                                 cpi     i_temp1, low (MAX_INT_FR*CLK_SCALE)
                                 ldi     i_temp3, high(MAX_INT_FR*CLK_SCALE)       ; test range high
                                 cpc     i_temp2, i_temp3
                                 brsh    extint1_fail                              ; through away
                                 cpi     i_temp1, low (MIN_INT_FR*CLK_SCALE)
                                 ldi     i_temp3, high(MIN_INT_FR*CLK_SCALE)       ; test range low
                                 cpc     i_temp2, i_temp3
                                 brlo    extint1_fail                              ; through away
                                 sbr     flags2, (1<<RC_INTERVAL_OK)               ; set to rc impuls value is ok !
                                 rjmp    extint1_exit
                 extint1_fail:   tst     control_timeout
                                 breq    extint1_exit
                                 dec     control_timeout
                                 rjmp    extint1_exit
                                 ; rc impuls is at low state
                 falling_edge:   sbic    PIND, rcp_in                              ; test level of rc impuls
                                 rjmp    extint1_exit                              ; seems to be a spike
                                 ldi     i_temp1, (1<<ISC01)+(1<<ISC00)
                                 out     MCUCR, i_temp1                            ; set next int0 to rising edge
                                 sbrc    flags1, RC_PULS_UPDATED
                                 rjmp    extint1_exit
                                 ; get timer1 values
                                 in      i_temp1, TCNT1L
                                 in      i_temp2, TCNT1H
                                 sts     stop_rcpuls_l, i_temp1                    ; prepare next interval evaluation
                                 sts     stop_rcpuls_h, i_temp2
                                 sbrs    flags2, RC_INTERVAL_OK
                                 rjmp    extint1_exit
                                 cbr     flags2, (1<<RC_INTERVAL_OK)               ; flag is evaluated
                                 sub     i_temp1, start_rcpuls_l
                                 sbc     i_temp2, start_rcpuls_h
                                 ; save impuls length
                                 sts     new_rcpuls_l, i_temp1
                                 sts     new_rcpuls_h, i_temp2
                                 cpi     i_temp1, low (MAX_INT_RF*CLK_SCALE)
                                 ldi     i_temp3, high(MAX_INT_RF*CLK_SCALE)       ; test range high
                                 cpc     i_temp2, i_temp3
                                 brsh    extint1_fail                              ; through away
                                 cpi     i_temp1, low (MIN_INT_RF*CLK_SCALE)
                                 ldi     i_temp3, high(MIN_INT_RF*CLK_SCALE)       ; test range low
                                 cpc     i_temp2, i_temp3
                                 brlo    extint1_fail                              ; through away
                                 sbr     flags1, (1<<RC_PULS_UPDATED)              ; set to rc impuls value is ok !
                                 ldi     i_temp1, CONTROL_TOT*CLK_SCALE
                                 mov     control_timeout, i_temp1
                                 ; enable int1 again -  also entry for spike detect
                 extint1_exit:   
                                 out     SREG, i_sreg
                                 reti
                 .endm
                 
                 .macro enable_input
                                 ldi     temp4, EXT0_EN                            ; ext0int enable
                                 out     GIMSK, temp4                              ; enable ext0int
                 .endm 
                 
                 .macro disable_input
                                 ldi     temp4, EXT0_DIS                           ; disable ext0int
                                 out     GIMSK, temp4
                 .endm 
                 
                 .macro init_input
                                 ldi     temp1, (1<<ISC01)+(1<<ISC00)
                                 out     MCUCR, temp1                              ; set next int0 to rising edge
                                 enable_input
                 .endm
                 
                 .equ    POWER_RANGE   = 200
                 .equ    MIN_RC_PULS   = 1100
                 
                 ; falling->rising intervals
                 .equ    MAX_INT_FR    = 25000
                 .equ    MIN_INT_FR    = 15000
                 
                 ; rising->falling intervals
                 .equ    MAX_INT_RF    = 2200
                 .equ    MIN_INT_RF    = 800
                 
                 .macro EvaluatePWC
                                 cbr     flags1, (1<<EVAL_RC_PULS)
                                 sbrs    flags1, RC_PULS_UPDATED
                                 rjmp    eval_rc_p90
                                 lds     temp1, new_rcpuls_l
                                 lds     temp2, new_rcpuls_h
                                 cbr     flags1, (1<<RC_PULS_UPDATED) ; rc impuls value is read out
                                 subi    temp1, low  (MIN_RC_PULS*CLK_SCALE)
                                 sbci    temp2, high (MIN_RC_PULS*CLK_SCALE)
                                 brcc    eval_rc_p00
                                 clr     temp1
                                 clr     temp2
                 eval_rc_p00:    lsr     temp2
                                 ror     temp1
                                 lsr     temp2
                                 ror     temp1
                 .if CLK_SCALE==2
                                 lsr     temp2   ; actual 0->400
                                 ror     temp1
                 .endif
                                 mov     temp3, temp1            
                                 subi    temp1, POWER_RANGE
                                 brcs    eval_rc_p10
                                 ldi     temp3, POWER_RANGE
                 eval_rc_p10:    mov     ZH, temp3
                 eval_rc_p90:    ret
                 
                 .endmacro
                 ;Die Benutzung der Software ist mit folgenden Bedingungen verbunden:
                 
                 
                   cbi     ADCSRA, ADEN          ; disable ADC
                   in      temp1, SFIOR
                   sbr     temp1, (1<<ACME)      ; switch to comparator multiplexed
                   out     SFIOR, temp1
                 .endmacro  
                 
                 .macro ACNormal
                    cbr  temp1, (1<<ACME)        ; set to AN1
                    out  SFIOR, temp1
                    sbi  ADCSRA, ADEN            ; enable ADC
                 .endmacro  
                 
                 .macro ACChannel 
                    ldi   temp1, @0              
                    out   ADMUX, temp1
                 .endmacro  
                 
                 #define Typ "Mystery 20"
                 
                 
                 ;**** **** **** **** ****
                 ; PORT  definitions
                 ;**** **** **** **** ****
                 
                 ;*********************
                 ; PORT D 
                 ;*********************  
                 ;.equ			= 7	;
                 .equ	c_comp		= 6	;i common comparator input (AIN0)
                 .equ    AnFET           = 5     ;o
                 .equ	ApFET		= 4	;o
                 ;.equ			= 3	;
                 .equ	rcp_in		= 2	;i r/c pulse input
                 ;.equ			= 1	;
                 ;.equ                   = 0     ;
                 
                 
                 .equ	INIT_PD		= 0
                 .equ    DIR_PD          = (1<<ApFET)+(1<<AnFET)
                 .equ	BRAKE_PD	= (1<<AnFET)
                 
                 
                 ;*********************
                 ; ADC definitions
                 ;*********************
                 
                 .equ    mux_c           = 0     ; ADC0
                 .equ    mux_a           = 6     ; ADC6
                 .equ    mux_b           = 7     ; ADC7
                 .equ    ACCU_MUX        = 2     ; ADC2 voltage control input 
                 
                 ;*********************
                 ; PORT C definitions *
                 ;*********************
                 .equ    AnRef           = 1
                 .equ    CpFET           = 3
                 .equ    BnFET           = 4
                 .equ    BpFET           = 5  
                 
                 
                 .equ    INIT_PC         = (1<<AnRef)
                 .equ    DIR_PC          = (1<<AnRef)+(1<<CpFET)+(1<<BnFET)+(1<<BpFET)
                 .equ    BRAKE_PC        = (1<<BnFET)
                 
                 
                 ;*********************
                 ; PORT B definitions *
                 ;*********************
                 ;.equ		= 7	
                 ;.equ		= 6	
                 .equ	DbgLED	= 5;    (sck stk200 interface) 
                 ;.equ		= 4	(miso stk200 interface)
                 ;.equ		= 3	(mosi stk200 interface) 
                 ;.equ		= 2	
                 ;.equ		= 1	
                 .equ	CnFET	= 0
                 
                 .equ	INIT_PB		= 0
                 .equ    DIR_PB          = (1<<CnFET)+(1<<DbgLED)
                 .equ    BRAKE_PB        = (1<<CnFET)
                 
                 
                 #define DbgLEDOn        sbi     PORTB,5
                 #define DbgLEDOff       cbi     PORTB,5
                 
                 
                 ;*********************
                 ; FET Control        *
                 ;*********************
                 #define ApFET_on        sbi     PORTD,4
                 #define ApFET_off       cbi     PORTD,4
                 #define AnFET_on        sbi     PORTD,5
                 #define AnFET_off       cbi     PORTD,5
                 
                 #define BpFET_on        sbi     PORTC,5
                 #define BpFET_off       cbi     PORTC,5
                 #define BnFET_on        sbi     PORTC,4
                 #define BnFET_off       cbi     PORTC,4
                 
                 #define CpFET_on        sbi     PORTC,3
                 #define CpFET_off       cbi     PORTC,3
                 #define CnFET_on        sbi     PORTB,0
                 #define CnFET_off       cbi     PORTB,0
                 
                 
                 ;*************************
                 ; Comparator definitions *
                 ;*************************
                 
                 .macro AcInit
                   ACMultiplexed
                 .endmacro
                 
                 
                 .macro AcPhaseA
                   ACChannel mux_a
                 .endmacro
                 
                 
                 .macro AcPhaseB
                   ACChannel mux_b
                 .endmacro
                 
                 
                 .macro AcPhaseC
                   ACChannel mux_c
                 .endmacro
                 
                 
                 ;*************************
                 ; Parameters             *
                 ;*************************
                 .equ MOT_BRAKE        = 0
                 .equ CLK_SCALE        = 2                       ; 16Mhz external crystal
                 .equ READ_CALIBRATION = 0                       ;
                 
                 ;*************************
                 ; Timings                *
                 ;*************************
                 .equ    MIN_DUTY        = 3*POWER_RANGE/100     ; Min power 3%
                 
                 .equ    PWR_MAX_RPM1    = POWER_RANGE/4
                 .equ    PWR_MAX_RPM2    = POWER_RANGE/2
                 
                 .equ	PWR_STARTUP	= 5*POWER_RANGE/100     ;  5%
                 .equ    PWR_MAX_STARTUP = 12*POWER_RANGE/100    ; 15%
                 
                 
                 .equ	timeoutSTART	= 65000
                 .equ	timeoutMIN	= 48000
                 
                 .equ	PWR_RANGE1	= 0x40	; ( ~2400 RPM )
                 .equ	PWR_RANGE2	= 0x20	; ( ~4800 RPM )
                 
                 .equ	ENOUGH_GOODIES	= 60
                 
                 ;
                 ;Die Benutzung der Software ist mit folgenden Bedingungen verbunden:
                 ;
                 ;1. Da ich alles kostenlos zur Verfügung stelle, gebe ich keinerlei Garantie
                 ;   und übernehme auch keinerlei Haftung für die Folgen der Benutzung.
                 ;
                 ;2. Die Software ist ausschließlich zur privaten Nutzung bestimmt. Ich
                 ;   habe nicht geprüft, ob bei gewerblicher Nutzung irgendwelche Patentrechte
                 ;   verletzt werden oder sonstige rechtliche Einschränkungen vorliegen.
                 ;
                 ;3. Jeder darf Änderungen vornehmen, z.B. um die Funktion seinen Bedürfnissen
                 ;   anzupassen oder zu erweitern. Ich würde mich freuen, wenn ich weiterhin als
                 ;   Co-Autor in den Unterlagen erscheine und mir ein Link zur entprechenden Seite
                 ;   (falls vorhanden) mitgeteilt wird.
                 ;
                 ;4. Auch nach den Änderungen sollen die Software weiterhin frei sein, d.h. kostenlos bleiben.
                 ;
                 ;!! Wer mit den Nutzungbedingungen nicht einverstanden ist, darf die Software nicht nutzen !!
                 .include "m8def.inc"
                 
                 ;***** Created: 2007-02-28 07:32 ******* Source: ATmega8.xml *************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m8def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega8
                 ;* Date              : 2007-02-28
                 ;* Version           : 2.24
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega8
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M8DEF_INC_
                 #define _M8DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega8
                 #pragma AVRPART ADMIN PART_NAME ATmega8
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x93
                 .equ	SIGNATURE_002	= 0x07
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	GICR	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCR	= 0x37
                 .equ	TWCR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUCSR	= 0x34
                 .equ	TCCR0	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	SFIOR	= 0x30
                 .equ	TCCR1A	= 0x2f
                 .equ	TCCR1B	= 0x2e
                 .equ	TCNT1L	= 0x2c
                 .equ	TCNT1H	= 0x2d
                 .equ	OCR1AL	= 0x2a
                 .equ	OCR1AH	= 0x2b
                 .equ	OCR1BL	= 0x28
                 .equ	OCR1BH	= 0x29
                 .equ	ICR1L	= 0x26
                 .equ	ICR1H	= 0x27
                 .equ	TCCR2	= 0x25
                 .equ	TCNT2	= 0x24
                 .equ	OCR2	= 0x23
                 .equ	ASSR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	UBRRH	= 0x20
                 .equ	UCSRC	= 0x20
                 .equ	EEARL	= 0x1e
                 .equ	EEARH	= 0x1f
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PORTC	= 0x15
                 .equ	DDRC	= 0x14
                 .equ	PINC	= 0x13
                 .equ	PORTD	= 0x12
                 .equ	DDRD	= 0x11
                 .equ	PIND	= 0x10
                 .equ	SPDR	= 0x0f
                 .equ	SPSR	= 0x0e
                 .equ	SPCR	= 0x0d
                 .equ	UDR	= 0x0c
                 .equ	UCSRA	= 0x0b
                 .equ	UCSRB	= 0x0a
                 .equ	UBRRL	= 0x09
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCL	= 0x04
                 .equ	ADCH	= 0x05
                 .equ	TWDR	= 0x03
                 .equ	TWAR	= 0x02
                 .equ	TWSR	= 0x01
                 .equ	TWBR	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; SFIOR - Special Function IO Register
                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; GICR - General Interrupt Control Register
                 .equ	GIMSK	= GICR	; For compatibility
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                 
                 ; GIFR - General Interrupt Flag Register
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 .equ	INTF1	= 7	; External Interrupt Flag 1
                 
                 ; MCUCR - MCU Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 
                 ; TCCR0 - Timer/Counter0 Control Register
                 .equ	CS00	= 0	; Clock Select0 bit 0
                 .equ	CS01	= 1	; Clock Select0 bit 1
                 .equ	CS02	= 2	; Clock Select0 bit 2
                 
                 ; TCNT0 - Timer Counter 0
                 .equ	TCNT00	= 0	; Timer Counter 0 bit 0
                 .equ	TCNT01	= 1	; Timer Counter 0 bit 1
                 .equ	TCNT02	= 2	; Timer Counter 0 bit 2
                 .equ	TCNT03	= 3	; Timer Counter 0 bit 3
                 .equ	TCNT04	= 4	; Timer Counter 0 bit 4
                 .equ	TCNT05	= 5	; Timer Counter 0 bit 5
                 .equ	TCNT06	= 6	; Timer Counter 0 bit 6
                 .equ	TCNT07	= 7	; Timer Counter 0 bit 7
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	FOC1B	= 2	; Force Output Compare 1B
                 .equ	FOC1A	= 3	; Force Output Compare 1A
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	CTC1	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                 .equ	OCF2	= 7	; Output Compare Flag 2
                 
                 ; TCCR2 - Timer/Counter2 Control Register
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM21	= 3	; Waveform Generation Mode
                 .equ	CTC2	= WGM21	; For compatibility
                 .equ	COM20	= 4	; Compare Output Mode bit 0
                 .equ	COM21	= 5	; Compare Output Mode bit 1
                 .equ	WGM20	= 6	; Waveform Genration Mode
                 .equ	PWM2	= WGM20	; For compatibility
                 .equ	FOC2	= 7	; Force Output Compare
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2 - Timer/Counter2 Output Compare Register
                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                 
                 
                 ; ***** USART ************************
                 ; UDR - USART I/O Data Register
                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSRA - USART Control and Status Register A
                 .equ	USR	= UCSRA	; For compatibility
                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                 .equ	U2X	= 1	; Double the USART transmission speed
                 .equ	UPE	= 2	; Parity Error
                 .equ	PE	= UPE	; For compatibility
                 .equ	DOR	= 3	; Data overRun
                 .equ	FE	= 4	; Framing Error
                 .equ	UDRE	= 5	; USART Data Register Empty
                 .equ	TXC	= 6	; USART Transmitt Complete
                 .equ	RXC	= 7	; USART Receive Complete
                 
                 ; UCSRB - USART Control and Status Register B
                 .equ	UCR	= UCSRB	; For compatibility
                 .equ	TXB8	= 0	; Transmit Data Bit 8
                 .equ	RXB8	= 1	; Receive Data Bit 8
                 .equ	UCSZ2	= 2	; Character Size
                 .equ	CHR9	= UCSZ2	; For compatibility
                 .equ	TXEN	= 3	; Transmitter Enable
                 .equ	RXEN	= 4	; Receiver Enable
                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSRC - USART Control and Status Register C
                 .equ	UCPOL	= 0	; Clock Polarity
                 .equ	UCSZ0	= 1	; Character Size
                 .equ	UCSZ1	= 2	; Character Size
                 .equ	USBS	= 3	; Stop Bit Select
                 .equ	UPM0	= 4	; Parity Mode Bit 0
                 .equ	UPM1	= 5	; Parity Mode Bit 1
                 .equ	UMSEL	= 6	; USART Mode Select
                 .equ	URSEL	= 7	; Register Select
                 
                 .equ	UBRRHI	= UBRRH	; For compatibility
                 
                 ; ***** TWI **************************
                 ; TWBR - TWI Bit Rate register
                 .equ	I2BR	= TWBR	; For compatibility
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	I2CR	= TWCR	; For compatibility
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	I2IE	= TWIE	; For compatibility
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	I2EN	= TWEN	; For compatibility
                 .equ	ENI2C	= TWEN	; For compatibility
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	I2WC	= TWWC	; For compatibility
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	I2STO	= TWSTO	; For compatibility
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	I2STA	= TWSTA	; For compatibility
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	I2EA	= TWEA	; For compatibility
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 .equ	I2INT	= TWINT	; For compatibility
                 
                 ; TWSR - TWI Status Register
                 .equ	I2SR	= TWSR	; For compatibility
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWS0	= TWPS0	; For compatibility
                 .equ	I2GCE	= TWPS0	; For compatibility
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS1	= TWPS1	; For compatibility
                 .equ	TWS3	= 3	; TWI Status
                 .equ	I2S3	= TWS3	; For compatibility
                 .equ	TWS4	= 4	; TWI Status
                 .equ	I2S4	= TWS4	; For compatibility
                 .equ	TWS5	= 5	; TWI Status
                 .equ	I2S5	= TWS5	; For compatibility
                 .equ	TWS6	= 6	; TWI Status
                 .equ	I2S6	= TWS6	; For compatibility
                 .equ	TWS7	= 7	; TWI Status
                 .equ	I2S7	= TWS7	; For compatibility
                 
                 ; TWDR - TWI Data register
                 .equ	I2DR	= TWDR	; For compatibility
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	I2AR	= TWAR	; For compatibility
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EEWEE	= EEMWE	; For compatibility
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 .equ	SM0	= 4	; Sleep Mode Select
                 .equ	SM1	= 5	; Sleep Mode Select
                 .equ	SM2	= 6	; Sleep Mode Select
                 .equ	SE	= 7	; Sleep Enable
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	MCUSR	= MCUCSR	; For compatibility
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; SPMCR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write Section Read Enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PUD	= 2	; Pull-up Disable
                 .equ	ADHSM	= 4	; ADC High Speed Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADCSR	= ADCSRA	; For compatibility
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADFR	= 5	; ADC  Free Running Select
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	BODEN	= 6	; Brown out detector enable
                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	CKOPT	= 4	; Oscillator Options
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	WTDON	= 6	; Enable watchdog
                 .equ	RSTDISBL	= 7	; Disable reset
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 1024
                 .equ	RAMEND	= 0x045f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x01ff
                 .equ	EEPROMEND	= 0x01ff
                 .equ	EEADRBITS	= 9
                 #pragma AVRPART MEMORY PROG_FLASH 8192
                 #pragma AVRPART MEMORY EEPROM 512
                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0xc00
                 .equ	NRWW_STOP_ADDR	= 0xfff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0xbff
                 .equ	PAGESIZE	= 32
                 .equ	FIRSTBOOTSTART	= 0xf80
                 .equ	SECONDBOOTSTART	= 0xf00
                 .equ	THIRDBOOTSTART	= 0xe00
                 .equ	FOURTHBOOTSTART	= 0xc00
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                 .equ	OC2addr	= 0x0003	; Timer/Counter2 Compare Match
                 .equ	OVF2addr	= 0x0004	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0005	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0006	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0007	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x0008	; Timer/Counter1 Overflow
                 .equ	OVF0addr	= 0x0009	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x000a	; Serial Transfer Complete
                 .equ	URXCaddr	= 0x000b	; USART, Rx Complete
                 .equ	UDREaddr	= 0x000c	; USART Data Register Empty
                 .equ	UTXCaddr	= 0x000d	; USART, Tx Complete
                 .equ	ADCCaddr	= 0x000e	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x000f	; EEPROM Ready
                 .equ	ACIaddr	= 0x0010	; Analog Comparator
                 .equ	TWIaddr	= 0x0011	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0012	; Store Program Memory Ready
                 
                 .equ	INT_VECTORS_SIZE	= 19	; size in words
                 
                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                 
                 #endif  /* _M8DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 .equ    NO_POWER         = 256-MIN_DUTY         ; (POWER_OFF)
                 .equ    MAX_POWER        = 256-POWER_RANGE      ; (FULL_POWER)
                 .equ    CONTROL_TOT      = 50                   ; time = NUMBER x 64ms
                 .equ    CURRENT_ERR_MAX  = 3                    ; performs a reset after MAX errors
                 
                 .equ    T1STOP     = 0x00
                 .equ    T1CK8      = 0x02
                 
                 ;**** **** **** **** ****
                 ; Register Definitions
                 .def    i_sreg           = r1   ; status register save in interrupts
                 .def    tcnt0_power_on   = r2   ; timer0 counts nFETs are switched on
                 ;.def   ...              = r3   ; 
                 ;.def   ...              = r4   ; 
                 ;.def   ...              = r5   ;
                 .def    tcnt0_pwroff     = r6   ; timer0 counts nFETs are switched off
                 
                 .def    start_rcpuls_l   = r7
                 .def    start_rcpuls_h   = r8
                 .def    motor_count      = r9
                 ;.def                    = r10
                 .def    control_timeout  = r11
                 .def    current_err      = r12  ; counts consecutive current errors
                 
                 .def    sys_control      = r13
                 .def    t1_timeout       = r14
                 .def    run_control      = r15
                 
                 
                 .def    temp1   = r16                   ; main temporary
                 .def    temp2   = r17                   ; main temporary
                 .def    temp3   = r18                   ; main temporary
                 .def    temp4   = r19                   ; main temporary
                 
                 .def    i_temp1 = r20                   ; interrupt temporary
                 .def    i_temp2 = r21                   ; interrupt temporary
                 .def    i_temp3 = r22                   ; interrupt temporary
                 
                 .def    flags0  = r23   ; state flags
                         .equ    OCT1_PENDING    = 0     ; if set, output compare interrunpt is pending
                         .equ    UB_LOW          = 1     ; set if accu voltage low
                         .equ    I_pFET_HIGH     = 2     ; set if over-current detect
                         .equ    GET_STATE       = 3     ; set if state is to be send
                         .equ    C_FET           = 4     ; if set, C-FET state is to be changed
                         .equ    A_FET           = 5     ; if set, A-FET state is to be changed
                              ; if neither 1 nor 2 is set, B-FET state is to be changed
                         .equ    I_OFF_CYCLE     = 6     ; if set, current off cycle is active
                         .equ    T1OVFL_FLAG     = 7     ; each timer1 overflow sets this flag - used for voltage + current watch
                 
                 .def    flags1  = r24   ; state flags
                         .equ    POWER_OFF       = 0     ; switch fets on disabled
                         .equ    FULL_POWER      = 1     ; 100% on - don't switch off, but do OFF_CYCLE working
                         .equ    CALC_NEXT_OCT1  = 2     ; calculate OCT1 offset, when wait_OCT1_before_switch is called
                         .equ    RC_PULS_UPDATED = 3     ; new rc-puls value available
                         .equ    EVAL_RC_PULS    = 4     ; if set, new rc puls is evaluated, while waiting for OCT1
                         .equ    EVAL_SYS_STATE  = 5     ; if set, overcurrent and undervoltage are checked
                         .equ    EVAL_RPM        = 6     ; if set, next PWM on should look for current
                         .equ    EVAL_PWM        = 7     ; if set, PWM should be updated
                 
                 .def    flags2  = r25
                         .equ    RPM_RANGE1      = 0     ; if set RPM is lower than 1831 RPM
                         .equ    RPM_RANGE2      = 1     ; if set RPM is between 1831 RPM and 3662 RPM
                         .equ    SCAN_TIMEOUT    = 2     ; if set a startup timeout occurred
                         .equ    POFF_CYCLE      = 3     ; if set one commutation cycle is performed without power
                         .equ    COMP_SAVE       = 4     ; if set ACO was high
                         .equ    STARTUP         = 5     ; if set startup-phase is active
                         .equ    RC_INTERVAL_OK  = 6     ; 
                         .equ    NO_SYNC         = 7     ; 
                 
                 ; here the XYZ registers are placed ( r26-r31)
                 
                 ; ZH = new_duty         ; PWM destination
                 
                 
                 ;**** **** **** **** ****
                 ; RAM Definitions
                 .dseg                                   ;EEPROM segment
                 .org SRAM_START
                 
000060           tcnt1_sav_l:    .byte   1       ; actual timer1 value
000061           tcnt1_sav_h:    .byte   1
000062           last_tcnt1_l:   .byte   1       ; last timer1 value
000063           last_tcnt1_h:   .byte   1
000064           timing_l:       .byte   1       ; holds time of 4 commutations 
000065           timing_h:       .byte   1
000066           timing_x:       .byte   1
                 
000067           timing_acc_l:   .byte   1       ; holds the average time of 4 commutations 
000068           timing_acc_h:   .byte   1
000069           timing_acc_x:   .byte   1
                 
00006a           rpm_l:          .byte   1       ; holds the average time of 4 commutations 
00006b           rpm_h:          .byte   1
00006c           rpm_x:          .byte   1
                 
00006d           wt_comp_scan_l: .byte   1       ; time from switch to comparator scan
00006e           wt_comp_scan_h: .byte   1       
00006f           com_timing_l:   .byte   1       ; time from zero-crossing to switch of the appropriate FET
000070           com_timing_h:   .byte   1
000071           wt_OCT1_tot_l:  .byte   1       ; OCT1 waiting time
000072           wt_OCT1_tot_h:  .byte   1
000073           zero_wt_l:      .byte   1
000074           zero_wt_h:      .byte   1
000075           last_com_l:     .byte   1
000076           last_com_h:     .byte   1
                 
000077           stop_rcpuls_l:  .byte   1
000078           stop_rcpuls_h:  .byte   1
000079           new_rcpuls_l:   .byte   1
00007a           new_rcpuls_h:   .byte   1
                 
00007b           duty_offset:    .byte   1
00007c           goodies:        .byte   1
00007d           comp_state:     .byte   1
00007e           uart_command:   .byte   1
                 
00007f           uart_data:      .byte   100             ; only for debug requirements
                 
                 
                 ;**** **** **** **** ****
                 ; ATmega8 interrupts
                 
                 ;.equ   INT0addr=$001   ; External Interrupt0 Vector Address
                 ;.equ   INT1addr=$002   ; External Interrupt1 Vector Address
                 ;.equ   OC2addr =$003   ; Output Compare2 Interrupt Vector Address
                 ;.equ   OVF2addr=$004   ; Overflow2 Interrupt Vector Address
                 ;.equ   ICP1addr=$005   ; Input Capture1 Interrupt Vector Address
                 ;.equ   OC1Aaddr=$006   ; Output Compare1A Interrupt Vector Address
                 ;.equ   OC1Baddr=$007   ; Output Compare1B Interrupt Vector Address
                 ;.equ   OVF1addr=$008   ; Overflow1 Interrupt Vector Address
                 ;.equ   OVF0addr=$009   ; Overflow0 Interrupt Vector Address
                 ;.equ   SPIaddr =$00a   ; SPI Interrupt Vector Address
                 ;.equ   URXCaddr=$00b   ; USART Receive Complete Interrupt Vector Address
                 ;.equ   UDREaddr=$00c   ; USART Data Register Empty Interrupt Vector Address
                 ;.equ   UTXCaddr=$00d   ; USART Transmit Complete Interrupt Vector Address
                 ;.equ   ADCCaddr=$00e   ; ADC Interrupt Vector Address
                 ;.equ   ERDYaddr=$00f   ; EEPROM Interrupt Vector Address
                 ;.equ   ACIaddr =$010   ; Analog Comparator Interrupt Vector Address
                 ;.equ   TWIaddr =$011   ; Irq. vector address for Two-Wire Interface
                 ;.equ   SPMaddr =$012   ; SPM complete Interrupt Vector Address
                 ;.equ   SPMRaddr =$012  ; SPM complete Interrupt Vector Address
                 ;-----bko-----------------------------------------------------------------
                 
                 ;**** **** **** **** ****
                 .cseg
                 .org 0
                 ;**** **** **** **** ****
                 
                 ;-----bko-----------------------------------------------------------------
                 ; reset and interrupt jump table
                 
                 #if !defined(__ext_int0)
                 #endif
                 
                 #if !defined(__ext_int1)
                  #define __ext_int1 reti 
                  .macro __ext_int1_isr
                  .endmacro
                 #endif
                 
000000 c01d                      rjmp    reset
000001 c06b                      __ext_int0          ; ext_int0
000002 9518                      __ext_int1          ; ext_int1
000003 9518                      reti                ; t2oc_int
000004 9518                      reti                ; t2ovfl_int
000005 9518                      reti                ; icp1
000006 c0a9                      rjmp    t1oca_int
000007 9518                      reti                ; t1ocb_int
000008 c0ab                      rjmp    t1ovfl_int
000009 c0b6                      rjmp    t0ovfl_int
00000a 9518                      reti                ; spi_int
00000b 9518                      reti                ; urxc
00000c 9518                      reti                ; udre
00000d 9518                      reti                ; utxc
00000e 9518                      reti                ; adc_int
00000f 9518                      reti                ; eep_int
000010 9518                      reti                ; aci_int
000011 9518                      reti                ; wire2_int
000012 9518                      reti                ; spmc_int
                 
                 
000013 0a0d      version:        .db     0x0d, 0x0a
000014 6b62
000015 794d
000016 7473
000017 7265
000018 2079
000019 3032
00001a 3134
00001b 7230
00001c 3630                      .db     "bk",Typ,"410r06"
00001d 0a0d                      .db     0x0d, 0x0a
                 
                 ;******************************************************************************
                 ;* MACRO
                 ;*      SetPWMi
                 ;* DECRIPTION
                 ;*      Set PWM immidiate
                 ;* USAGE
                 ;*      SetPWMi(val)
                 ;* STATISTICS
                 ;*      Register usage: none
                 ;******************************************************************************
                 .macro SetPWMi
                                 push    temp1
                                 ldi     temp1, @0
                                 com     temp1
                                 rcall   set_pwm
                 ;                rcall   eval_power_state
                                 pop     temp1
                 .endmacro
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; init after reset
                 
00001e e004      reset:          ldi     temp1, high(RAMEND)     ; stack = RAMEND
00001f bf0e                      out     SPH, temp1
000020 e50f                      ldi     temp1, low(RAMEND)
000021 bf0d                      out     SPL, temp1
                 
                 .if READ_CALIBRATION == 1
                 .endif
                 
                         ; portB
000022 e000                      ldi     temp1, INIT_PB
000023 bb08                      out     PORTB, temp1
000024 e201                      ldi     temp1, DIR_PB
000025 bb07                      out     DDRB, temp1
                 
                         ; portC
000026 e002                      ldi     temp1, INIT_PC
000027 bb05                      out     PORTC, temp1
000028 e30a                      ldi     temp1, DIR_PC
000029 bb04                      out     DDRC, temp1
                 
                         ; portD
00002a e000                      ldi     temp1, INIT_PD
00002b bb02                      out     PORTD, temp1
00002c e300                      ldi     temp1, DIR_PD
00002d bb01                      out     DDRD, temp1
                 
                         ; timer0: PWM + beep control = 0x02     ; start timer0 with CK/8 (0.5³s/count)
00002e e002                      ldi     temp1, 0x02
00002f bf03                      out     TCCR0, temp1
                 
                         ; timer1: commutation control = 0x02    ; start timer1 with CK/8 (0.5³s/count)
000030 e002                      ldi     temp1, T1CK8
000031 bd0e                      out     TCCR1B, temp1
                 
                         ; reset state flags
000032 2777                      clr     flags0
000033 2788                      clr     flags1
000034 2799                      clr     flags2
                 
                         ; clear RAM
000035 27bb                      clr     XH
000036 e6a0                      ldi     XL, low (SRAM_START)
000037 2700                      clr     temp1
000038 930d      clear_ram:      st      X+, temp1
000039 38a0                      cpi     XL, uart_data+1
00003a f3e8                      brlo    clear_ram
                 
                         ; power off
00003b d275                      rcall   switch_power_off
                 
                         ; reset rc puls timeout
00003c e604                      ldi     temp1, CONTROL_TOT*CLK_SCALE
00003d 2eb0                      mov     control_timeout, temp1
                                 
00003e d0d9                      rcall   wait260ms       ; wait a while
00003f d0d8                      rcall   wait260ms
                 
000040 d0ab                      rcall   beep_f1
000041 d0ca                      rcall   wait30ms
000042 d0ac                      rcall   beep_f2
000043 d0c8                      rcall   wait30ms
000044 d0ad                      rcall   beep_f3
000045 d0c6                      rcall   wait30ms
                 
                 control_start:  ; init variables
000046 930f
000047 e005
000048 9500
000049 d10c
00004a 910f                      SetPWMi(MIN_DUTY-1)
00004b e000                      ldi     temp1, 0                ; reset error counters
00004c 2ec0                      mov     current_err,temp1
00004d 2ed0                      mov     sys_control, temp1
                 
                         ; init registers and interrupts
00004e e105                      ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
00004f bf08                      out     TIFR, temp1             ; clear TOIE1,OCIE1A & TOIE0
000050 bf09                      out     TIMSK, temp1            ; enable TOIE1,OCIE1A & TOIE0 interrupts
                 
000051 9478                      sei                             ; enable all interrupts
                 
000052 e003
000053 bf05
000054 e430
000055 bf3b                      init_input
000056 e02a      i_rc_puls1:     ldi     temp3, 10               ; wait for this count of receiving power off
000057 ff83      i_rc_puls2:     sbrs    flags1, RC_PULS_UPDATED
000058 cffe                      rjmp    i_rc_puls2
000059 9100 0079                 lds     temp1, new_rcpuls_l
00005b 9110 007a                 lds     temp2, new_rcpuls_h
00005d 7f87                      cbr     flags1, (1<<RC_PULS_UPDATED) ; rc impuls value is read out
00005e 5908                      subi    temp1, low  (MIN_RC_PULS*CLK_SCALE)     ; power off received ?
00005f 4018                      sbci    temp2, high (MIN_RC_PULS*CLK_SCALE)
000060 f7a8                      brcc    i_rc_puls1              ; no - reset counter
000061 952a                      dec     temp3                   ; yes - decrement counter
000062 f7a1                      brne    i_rc_puls2              ; repeat until zero
000063 94f8                      cli                             ; disable all interrupts
000064 d090                      rcall   beep_f4                 ; signal: rcpuls ready
000065 d08f                      rcall   beep_f4
000066 d08e                      rcall   beep_f4
000067 9478                      sei                             ; enable all interrupts
                 
000068 e10e                      ldi     temp1, 30
000069 9300 007b                 sts     duty_offset, temp1
                 
00006b d166                      rcall   set_all_timings
                 
00006c c28c                      rjmp    init_startup
                 ;-----bko-----------------------------------------------------------------
00006d b61f
00006e b745
00006f ff40
000070 c01d
000071 9b82
000072 c03b
000073 e042
000074 bf45
000075 b54c
000076 b55d
000077 2e74
000078 2e85
000079 7b9f
00007a 9160 0077
00007c 1b46
00007d 9160 0078
00007f 0b56
000080 3540
000081 ec63
000082 0756
000083 f430
000084 3340
000085 e765
000086 0756
000087 f010
000088 6490
000089 c024
00008a 20bb
00008b f111
00008c 94ba
00008d c020
00008e 9982
00008f c01e
000090 e043
000091 bf45
000092 fd83
000093 c01a
000094 b54c
000095 b55d
000096 9340 0077
000098 9350 0078
00009a ff96
00009b c012
00009c 7b9f
00009d 1947
00009e 0958
00009f 9340 0079
0000a1 9350 007a
0000a3 3340
0000a4 e161
0000a5 0756
0000a6 f718
0000a7 3440
0000a8 e066
0000a9 0756
0000aa f2f8
0000ab 6088
0000ac e644
0000ad 2eb4
0000ae be1f
0000af 9518      ext_int0_isr:   __ext_int0_isr
                 ext_int1_isr:   __ext_int1_isr
                 ;-----bko-----------------------------------------------------------------
                 ; output compare timer1 interrupt
0000b0 b61f      t1oca_int:      in      i_sreg, SREG
0000b1 7f7e                      cbr     flags0, (1<<OCT1_PENDING) ; signal OCT1 passed
0000b2 be1f                      out     SREG, i_sreg
0000b3 9518                      reti
                 ;-----bko-----------------------------------------------------------------
                 ; overflow timer1 / happens all 32768³s / 65536³s
0000b4 b61f      t1ovfl_int:     in      i_sreg, SREG
0000b5 6870                      sbr     flags0, (1<<T1OVFL_FLAG)
                 
0000b6 20ee                      tst     t1_timeout
0000b7 f009                      breq    t1ovfl_10
0000b8 94ea                      dec     t1_timeout
                 
0000b9 20bb      t1ovfl_10:      tst     control_timeout
0000ba f411                      brne    t1ovfl_20
0000bb 27ff                      clr     ZH
0000bc c001                      rjmp    t1ovfl_99
0000bd 94ba      t1ovfl_20:      dec     control_timeout
                 
0000be be1f      t1ovfl_99:      out     SREG, i_sreg
0000bf 9518                      reti
                 ;-----bko-----------------------------------------------------------------
                 ; timer0 overflow interrupt
0000c0 b61f      t0ovfl_int:     in      i_sreg, SREG
                 ;                DbgLEDOff
0000c1 fd76                      sbrc    flags0, I_OFF_CYCLE
0000c2 c014                      rjmp    t0_on_cycle
                 
                 t0_off_cycle:   
0000c3 be62                      out     TCNT0, tcnt0_pwroff     ; reload t0
                                 ; mirror inverted ACO to bit-var
0000c4 6190                      sbr     flags2, (1<<COMP_SAVE)
0000c5 9945                      sbic    ACSR, ACO               
0000c6 7e9f                      cbr     flags2, (1<<COMP_SAVE)
                                 ; PWM state = off cycle
0000c7 6470                      sbr     flags0, (1<<I_OFF_CYCLE)
                                 ; We can just turn them all off as we only have one nFET on at a
                                 ; time, and interrupts are disabled during beeps.
0000c8 98c0                      CnFET_off
0000c9 9895                      AnFET_off
0000ca 98ac                      BnFET_off
                 
                 
0000cb 2d46                      mov     i_temp1, tcnt0_pwroff
0000cc 3040                      cpi     i_temp1, 0
0000cd f021                      breq    t0_on_cycle_t1
0000ce 3041                      cpi     i_temp1, 1
0000cf f039                      breq    t0_on_cycle_t0
                 
0000d0 be1f                      out     SREG, i_sreg
0000d1 9518                      reti
                 
                 t0_on_cycle_t1:
0000d2 0000                      nop
0000d3 0000                      nop                
0000d4 0000                      nop
0000d5 0000                      nop                
0000d6 0000                      nop
                 ;                nop                
                 ;                nop
                 ;                nop                
                                 
                                 
                 t0_on_cycle_t0:
                 ;                nop
                 ;                nop      
                 ;                nop
                 ;                nop      
                 ;                DbgLEDOn          
                 
                 
                 t0_on_cycle:
0000d7 fd80                      sbrc    flags1, POWER_OFF
0000d8 c009                      rjmp    t0_on_cycle_tcnt
                                 ; switch appropriate nFET on as soon as possible
0000d9 ff74                      sbrs    flags0, C_FET           ; is Cn choppered ?
0000da c002                      rjmp    test_AnFET_on                   ; .. no - test An
0000db 9ac0                      CnFET_on                        ; Cn on
0000dc c005                      rjmp    t0_on_cycle_tcnt
0000dd ff75      test_AnFET_on:  sbrs    flags0, A_FET           ; is An choppered ?
0000de c002                      rjmp    sw_BnFET_on                     ; .. no - Bn has to be choppered
0000df 9a95                      AnFET_on                        ; An on
0000e0 c001                      rjmp    t0_on_cycle_tcnt
                 sw_BnFET_on:    
0000e1 9aac                      BnFET_on                        ; Bn on
                 t0_on_cycle_tcnt:
0000e2 7b7f                      cbr     flags0, (1<<I_OFF_CYCLE); PWM state = on cycle
0000e3 2d42                      mov     i_temp1, tcnt0_power_on
0000e4 7f8d                      cbr     flags1, (1<<FULL_POWER)
0000e5 3348                      cpi     i_temp1, MAX_POWER
0000e6 f410                      brsh    t0_on_cycle_not_full_power
0000e7 6082                      sbr     flags1, (1<<FULL_POWER)
0000e8 6470                      sbr     flags0, (1<<I_OFF_CYCLE)
                 t0_on_cycle_not_full_power:
0000e9 be22                      out     TCNT0, tcnt0_power_on   ; reload t0
0000ea be1f                      out     SREG, i_sreg
0000eb 9518                      reti                   
                 ;-----bko-----------------------------------------------------------------
                 ; beeper: timer0 is set to 1³s/count
0000ec ec38      beep_f1:        ldi     temp4, 200
0000ed e510                      ldi     temp2, 80
0000ee c009                      rjmp    beep
                 
0000ef eb34      beep_f2:        ldi     temp4, 180
0000f0 e614                      ldi     temp2, 100
0000f1 c006                      rjmp    beep
                 
0000f2 ea30      beep_f3:        ldi     temp4, 160
0000f3 e718                      ldi     temp2, 120
0000f4 c003                      rjmp    beep
                 
0000f5 e634      beep_f4:        ldi     temp4, 100
0000f6 ec18                      ldi     temp2, 200
0000f7 c000                      rjmp    beep
                 
0000f8 2700      beep:           clr     temp1
0000f9 bf02                      out     TCNT0, temp1
0000fa 9aad                      BpFET_on                ; BpFET on
0000fb 9a95                      AnFET_on                ; CnFET on
0000fc b702      beep_BpCn10:    in      temp1, TCNT0
0000fd 3400                      cpi     temp1, 32*CLK_SCALE             ; 32³s on
0000fe f7e9                      brne    beep_BpCn10
0000ff 98ad                      BpFET_off               ; BpFET off
000100 9895                      AnFET_off               ; CnFET off
000101 e120                      ldi     temp3, 8*CLK_SCALE              ; 2040³s off
000102 2700      beep_BpCn12:    clr     temp1
000103 bf02                      out     TCNT0, temp1
000104 b702      beep_BpCn13:    in      temp1, TCNT0
000105 1703                      cp      temp1, temp4
000106 f7e9                      brne    beep_BpCn13
000107 952a                      dec     temp3
000108 f7c9                      brne    beep_BpCn12
000109 951a                      dec     temp2
00010a f769                      brne    beep
00010b 9508                      ret
                 
00010c e11e      wait30ms:       ldi     temp2, 15*CLK_SCALE
00010d e120      beep_BpCn20:    ldi     temp3, 8*CLK_SCALE
00010e 2700      beep_BpCn21:    clr     temp1
00010f bf02                      out     TCNT0, temp1
000110 b702      beep_BpCn22:    in      temp1, TCNT0
000111 3f0f                      cpi     temp1, 255
000112 f7e9                      brne    beep_BpCn22
000113 952a                      dec     temp3
000114 f7c9                      brne    beep_BpCn21
000115 951a                      dec     temp2
000116 f7b1                      brne    beep_BpCn20
000117 9508                      ret
                 
                         ; 256 periods = 261ms silence
000118 ef1e      wait260ms:      ldi     temp2, 127*CLK_SCALE    ; = 256
000119 e120      beep2_BpCn20:   ldi     temp3, 8*CLK_SCALE
00011a 2700      beep2_BpCn21:   clr     temp1
00011b bf02                      out     TCNT0, temp1
00011c b702      beep2_BpCn22:   in      temp1, TCNT0
00011d 3f0f                      cpi     temp1, 255
00011e f7e9                      brne    beep2_BpCn22
00011f 952a                      dec     temp3
000120 f7c9                      brne    beep2_BpCn21
000121 951a                      dec     temp2
000122 f7b1                      brne    beep2_BpCn20
000123 9508                      ret                
                 ;-----bko-----------------------------------------------------------------
                 tcnt1_to_temp:  
000124 e030
000125 bf3b                      disable_input
000126 e030                      ldi     temp4, T1STOP           ; stop timer1
000127 bd3e                      out     TCCR1B, temp4
000128 e032                      ldi     temp4, T1CK8            ; preload temp with restart timer1
000129 b50c                      in      temp1, TCNT1L           ;  - the preload cycle is needed to complete stop operation
00012a b51d                      in      temp2, TCNT1H
00012b bd3e                      out     TCCR1B, temp4
00012c 9508                      ret                             ; !!! ext0int stays disabled - must be enabled again by caller
                         ; there seems to be only one TEMP register in the AVR
                         ; if the ext0int interrupt falls between readad LOW value while HIGH value is captured in TEMP and
                         ; read HIGH value, TEMP register is changed in ext0int routine
                 ;-----bko-----------------------------------------------------------------
                 evaluate_rc_puls:
00012d 7e8f
00012e ff83
00012f c015
000130 9100 0079
000132 9110 007a
000134 7f87
000135 5908
000136 4018
000137 f410
000138 2700
000139 2711
00013a 9516
00013b 9507
00013c 9516
00013d 9507
00013e 9516
00013f 9507
000140 2f20
000141 5c08
000142 f008
000143 ec28
000144 2ff2
000145 9508                      EvaluatePWC
                 ;-----bko-----------------------------------------------------------------
                 evaluate_sys_state:
000146 7d8f                      cbr     flags1, (1<<EVAL_SYS_STATE)
000147 ff77                      sbrs    flags0, T1OVFL_FLAG
000148 c00a                      rjmp    eval_sys_s99
                 
                         ; do it not more often as every 32³s
000149 777f                      cbr     flags0, (1<<T1OVFL_FLAG)
                 
                         ; control current
00014a c005      eval_sys_i:     rjmp    eval_sys_i_ok
                 
00014b 2d4c                      mov     i_temp1, current_err
00014c 3043                      cpi     i_temp1, CURRENT_ERR_MAX
00014d f430                      brcc    panic_exit
00014e 94c3                      inc     current_err
00014f c003                      rjmp    eval_sys_ub
                 
000150 20cc      eval_sys_i_ok:  tst     current_err
000151 f009                      breq    eval_sys_ub
000152 94ca                      dec     current_err
                 
                 eval_sys_ub:    
000153 9508      eval_sys_s99:   ret
                 
                 panic_exit:     ; !!!!!! OVERCURRENT !!!!!!!!
000154 94f8                      cli
000155 cec8                      rjmp    reset
                 ;-----bko-----------------------------------------------------------------
                 ;******************************************************************************
                 ;* FUNCTION
                 ;*      set_pwm
                 ;* DECRIPTION
                 ;*      Calculates tcnt0 values for ON and off cycles.
                 ;*      Performs PWM correction.
                 ;* USAGE
                 ;*      temp1
                 ;* STATISTICS
                 ;*      Register usage: temp1
                 ;******************************************************************************
                 set_pwm:
                 ;                inc     temp1                   ; Make it shorter by 3 cycles
                 ;                inc     temp1
                 ;                inc     temp1
000156 2e20                      mov     tcnt0_power_on, temp1
000157 5308                      subi    temp1, -POWER_RANGE     
000158 9500                      com     temp1   
000159 9503                      inc     temp1            
00015a 9503                      inc     temp1            
00015b 2e60                      mov     tcnt0_pwroff, temp1
00015c 9508                      ret
                 
                 ;******************************************************************************
                 ;* FUNCTION
                 ;*      eval_power_state
                 ;* DECRIPTION
                 ;*      Evaluates current state
                 ;* USAGE
                 ;*      temp1
                 ;* STATISTICS
                 ;*      Register usage: none
                 ;******************************************************************************
                 eval_power_state:
00015d 3309                      cpi     temp1, MAX_POWER+1
00015e f410                      brsh    not_full_power
                                 ; FULL POWER
                 ;               sbr     flags1, (1<<FULL_POWER) ; tcnt0_power_on = MAX_POWER means FULL_POWER
00015f 7f8e                      cbr     flags1, (1<<POWER_OFF)
                                 ;DbgLEDOn
000160 c005                      rjmp    eval_power_state_exit
000161 3f0a      not_full_power: cpi     temp1, NO_POWER
000162 f010                      brlo    neither_full_nor_off
                         ; POWER OFF
                 ;               cbr     flags1, (1<<FULL_POWER) ; tcnt0_power_on = NO_POWER means power off
000163 6081                      sbr     flags1, (1<<POWER_OFF)
                                 ;DbgLEDOff
000164 c001                      rjmp    eval_power_state_exit
                 neither_full_nor_off:
                 ;               cbr     flags1, (1<<FULL_POWER) ; tcnt0_power_on = MAX_POWER means FULL_POWER
000165 7f8e                      cbr     flags1, (1<<POWER_OFF)
                                 ;DbgLEDOff
                 eval_power_state_exit:    
000166 fd93                      sbrc    flags2, POFF_CYCLE
000167 6081                      sbr     flags1, (1<<POWER_OFF)
000168 9508                      ret
                 ;******************************************************************************
                 ;* FUNCTION
                 ;*      set_new_duty
                 ;* DECRIPTION
                 ;*     1) Evaluates duty cycle
                 ;*     2) Limits power to sys_control
                 ;*     3) Limits starup power
                 ;*     4) Limits RPM ranges power
                 ;*     5) Increments sys_control up to POWER_RANGE
                 ;* USAGE
                 ;*      ZH (0-POWER_RANGE)
                 ;* STATISTICS
                 ;*      Register usage: temp1, temp2, temp3 
                 ;******************************************************************************
                 set_new_duty:   
000169 2f0f                      mov     temp1, ZH
00016a 2d1d                      mov     temp2, sys_control      ; Limit PWM to sys_control
00016b 1701                      cp      temp1, temp2
00016c f020                      brcs    set_new_duty10
00016d 2f01                      mov     temp1, temp2
00016e 3c18                      cpi     temp2, POWER_RANGE
00016f f009                      breq    set_new_duty10
000170 94d3                      inc     sys_control             ; Build up sys_control to POWER_RANGE
000171 9110 0066 set_new_duty10: lds     temp2, timing_x
000173 2311                      tst     temp2
000174 f421                      brne    set_new_duty12
000175 9110 0065                 lds     temp2, timing_h         ; get actual RPM reference high
000177 3810                      cpi     temp2, PWR_RANGE1*CLK_SCALE ; lower range1 ?
000178 f038                      brcs    set_new_duty20          ; on carry - test next range ; lower as range1
000179 6091      set_new_duty12: sbr     flags2, (1<<RPM_RANGE1)
00017a 6092                      sbr     flags2, (1<<RPM_RANGE2)
00017b e312                      ldi     temp2, PWR_MAX_RPM1     ; higher than range1 power max ?
00017c 1701                      cp      temp1, temp2
00017d f060                      brcs    set_new_duty40          ; on carry - not higher, no restriction
00017e 2f01                      mov     temp1, temp2            ; low (range1) RPM - set PWR_MAX_RPM1
00017f c00a                      rjmp    set_new_duty40          ; higher as range1
000180 3410      set_new_duty20: cpi     temp2, PWR_RANGE2*CLK_SCALE; lower range2 ?
000181 f038                      brcs    set_new_duty30          ; on carry - not lower, no restriction
000182 7f9e      set_new_duty22: cbr     flags2, (1<<RPM_RANGE1)
000183 6092                      sbr     flags2, (1<<RPM_RANGE2)
000184 e614                      ldi     temp2, PWR_MAX_RPM2     ; higher than range2 power max ?
000185 1701                      cp      temp1, temp2
000186 f018                      brcs    set_new_duty40          ; on carry - not higher, no restriction
000187 2f01                      mov     temp1, temp2            ; low (range2) RPM - set PWR_MAX_RPM2
000188 c001                      rjmp    set_new_duty40          ; higher as range2
000189 7f9c      set_new_duty30: cbr     flags2, (1<<RPM_RANGE1)+(1<<RPM_RANGE2)  ; range limits are evaluated - look for STARTUP conditions
00018a ff95      set_new_duty40: sbrs    flags2, STARTUP
00018b c009                      rjmp    set_new_duty50
00018c e02a                      ldi     temp3, PWR_STARTUP      ; at least PWR_STARTUP ?
00018d 1702                      cp      temp1, temp3
00018e f410                      brcc    set_new_duty42          ; on no carry - higher than PWR_STARTUP, test PWR_MAX_STARTUP
00018f e00a                      ldi     temp1, PWR_STARTUP      ; lower - set to PWR_STARTUP
000190 c004                      rjmp    set_new_duty50
000191 e128      set_new_duty42: ldi     temp3, PWR_MAX_STARTUP  ; limit power in startup phase
000192 1702                      cp      temp1, temp3
000193 f008                      brcs    set_new_duty50          ; on carry - not higher, test range 2
000194 2f02                      mov     temp1, temp3            ; set PWR_MAX_STARTUP limit
000195 9500      set_new_duty50: com     temp1                   ; down-count to up-count (T0)
000196 94f8                      cli 
000197 dfc5                      rcall   eval_power_state        ; evaluate power state
000198 dfbd                      rcall   set_pwm                 ; set new PWM
000199 9478                      sei
00019a 9508                      ret
                 ;-----bko-----------------------------------------------------------------
00019b 7b8f      evaluate_rpm:   cbr     flags1, (1<<EVAL_RPM)
00019c 9120 006c                 lds     temp3, rpm_x
00019e 9110 006b                 lds     temp2, rpm_h
                 
0001a0 9100 006a                 lds     temp1, rpm_l    ; subtract 1/256
0001a2 1b01                      sub     temp1, temp2
0001a3 9300 006a                 sts     rpm_l, temp1
0001a5 9100 006b                 lds     temp1, rpm_h
0001a7 0b02                      sbc     temp1, temp3
0001a8 9300 006b                 sts     rpm_h, temp1
0001aa 9100 006c                 lds     temp1, rpm_x
0001ac 4000                      sbci    temp1, 0
0001ad 9300 006c                 sts     rpm_x, temp1
                 
0001af 9120 0069                 lds     temp3, timing_acc_x
0001b1 9110 0068                 lds     temp2, timing_acc_h
0001b3 9100 0067                 lds     temp1, timing_acc_l
0001b5 9526                      lsr     temp3           ; make one complete commutation cycle
0001b6 9517                      ror     temp2
0001b7 9507                      ror     temp1
0001b8 9526                      lsr     temp3
0001b9 9517                      ror     temp2
0001ba 9507                      ror     temp1
                         ; temp3 is zero now - for sure !!
0001bb 9320 0069                 sts     timing_acc_x, temp3
0001bd 9320 0068                 sts     timing_acc_h, temp3
0001bf 9320 0067                 sts     timing_acc_l, temp3
                         ; and add the result as 1/256
0001c1 9120 006a                 lds     temp3, rpm_l
0001c3 0f20                      add     temp3, temp1
0001c4 9320 006a                 sts     rpm_l, temp3
0001c6 9120 006b                 lds     temp3, rpm_h
0001c8 1f21                      adc     temp3, temp2
0001c9 9320 006b                 sts     rpm_h, temp3
0001cb e000                      ldi     temp1, 0
0001cc 9120 006c                 lds     temp3, rpm_x
0001ce 1f20                      adc     temp3, temp1
0001cf 9320 006c                 sts     rpm_x, temp3
                 
0001d1 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 set_all_timings:
0001d2 eec8                      ldi     YL, low  (timeoutSTART)
0001d3 efdd                      ldi     YH, high (timeoutSTART)
0001d4 93c0 0071                 sts     wt_OCT1_tot_l, YL
0001d6 93d0 0072                 sts     wt_OCT1_tot_h, YH
0001d8 ef2f                      ldi     temp3, 0xff
0001d9 e13f                      ldi     temp4, 0x1f
0001da 9320 006d                 sts     wt_comp_scan_l, temp3
0001dc 9330 006e                 sts     wt_comp_scan_h, temp4
0001de 9320 006f                 sts     com_timing_l, temp3
0001e0 9330 0070                 sts     com_timing_h, temp4
                 set_timing_v:   
                 .if CLK_SCALE==1
                 .endif                
                 .if CLK_SCALE==2
0001e2 e0e3                      ldi     ZL, 0x03
                 .endif                
0001e3 93e0 0066                 sts     timing_x, ZL
0001e5 ef3f                      ldi     temp4, 0xff
0001e6 9330 0065                 sts     timing_h, temp4
0001e8 ef2f                      ldi     temp3, 0xff
0001e9 9320 0064                 sts     timing_l, temp3
                 
0001eb 9508                      ret
                 ;-----bko-----------------------------------------------------------------
0001ec df37      update_timing:  rcall   tcnt1_to_temp
0001ed 9300 0060                 sts     tcnt1_sav_l, temp1
0001ef 9310 0061                 sts     tcnt1_sav_h, temp2
0001f1 0f0c                      add     temp1, YL
0001f2 1f1d                      adc     temp2, YH
0001f3 e035                      ldi     temp4, (1<<TOIE1)+(1<<TOIE0)
0001f4 bf39                      out     TIMSK, temp4
0001f5 bd1b                      out     OCR1AH, temp2
0001f6 bd0a                      out     OCR1AL, temp1
0001f7 6071                      sbr     flags0, (1<<OCT1_PENDING)
0001f8 e135                      ldi     temp4, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; enable interrupt again
0001f9 bf39                      out     TIMSK, temp4
0001fa e430
0001fb bf3b                      enable_input
                 
                         ; calculate next waiting times - timing(-l-h-x) holds the time of 4 commutations
0001fc 9100 0064                 lds     temp1, timing_l
0001fe 9110 0065                 lds     temp2, timing_h
000200 91e0 0066                 lds     ZL, timing_x
                 
000202 9300 0073                 sts     zero_wt_l, temp1        ; save for zero crossing timeout
000204 9310 0074                 sts     zero_wt_h, temp2
000206 23ee                      tst     ZL
000207 f029                      breq    update_t00
000208 ef3f                      ldi     temp4, 0xff
000209 9330 0073                 sts     zero_wt_l, temp4        ; save for zero crossing timeout
00020b 9330 0074                 sts     zero_wt_h, temp4
                 update_t00:
00020d 95e6                      lsr     ZL                      ; build a quarter
00020e 9517                      ror     temp2
00020f 9507                      ror     temp1
                 
000210 95e6                      lsr     ZL
000211 9517                      ror     temp2
000212 9507                      ror     temp1
000213 9120 0064                 lds     temp3, timing_l         ; .. and subtract from timing
000215 9130 0065                 lds     temp4, timing_h
000217 91e0 0066                 lds     ZL, timing_x
000219 1b20                      sub     temp3, temp1
00021a 0b31                      sbc     temp4, temp2
00021b 40e0                      sbci    ZL, 0
                 
00021c 9100 0060                 lds     temp1, tcnt1_sav_l      ; calculate this commutation time
00021e 9110 0061                 lds     temp2, tcnt1_sav_h
000220 91c0 0062                 lds     YL, last_tcnt1_l
000222 91d0 0063                 lds     YH, last_tcnt1_h
000224 9300 0062                 sts     last_tcnt1_l, temp1
000226 9310 0063                 sts     last_tcnt1_h, temp2
000228 1b0c                      sub     temp1, YL
000229 0b1d                      sbc     temp2, YH
00022a 9300 0075                 sts     last_com_l, temp1
00022c 9310 0076                 sts     last_com_h, temp2
                 
00022e 0f20                      add     temp3, temp1            ; .. and add to timing
00022f 1f31                      adc     temp4, temp2
000230 e010                      ldi     temp2, 0
000231 1fe1                      adc     ZL, temp2
                 
                         ; limit RPM to 120.000
000232 23ee                      tst     ZL
000233 f441                      brne    update_t90
000234 2333                      tst     temp4
000235 f021                      breq    update_t10
000236 3032                      cpi     temp4, 0x01*CLK_SCALE
000237 f421                      brne    update_t90
000238 3928                      cpi     temp3, 0x4c*CLK_SCALE   ; 120.000 RPM
000239 f410                      brcc    update_t90
                         ; set RPM to 120.000
                 
                 update_t10:
00023a e604                      ldi     temp1, PWR_MAX_RPM2
00023b 2ed0                      mov     sys_control, temp1
                 
                 ;update_t10:    ldi     temp4, 0x01*CLK_SCALE
                 ;               ldi     temp3, 0x4c*CLK_SCALE
                 ;               tst     run_control 
                 ;               brne    update_t90              ; just active
                 ;               ldi     temp1, 0xff             ; not active - reactivate
                 ;               mov     run_control, temp1
                 
00023c 9320 0064 update_t90:     sts     timing_l, temp3
00023e 9330 0065                 sts     timing_h, temp4
000240 93e0 0066                 sts     timing_x, ZL
                 .if CLK_SCALE==1
                 .endif                
                 .if CLK_SCALE==2                                
000242 30e4                      cpi     ZL, 0x04                ; limit range to 0x3ffff
                 .endif                
000243 f008                      brcs    update_t99
000244 df9d                      rcall   set_timing_v
                 
000245 9100 0067 update_t99:     lds     temp1, timing_acc_l
000247 0f02                      add     temp1, temp3
000248 9300 0067                 sts     timing_acc_l, temp1
00024a 9100 0068                 lds     temp1, timing_acc_h
00024c 1f03                      adc     temp1, temp4
00024d 9300 0068                 sts     timing_acc_h, temp1
00024f 9100 0069                 lds     temp1, timing_acc_x
000251 1f0e                      adc     temp1, ZL
000252 9300 0069                 sts     timing_acc_x, temp1
                 
000254 95e6                      lsr     ZL                      ; a 16th is the next wait before scan
000255 9537                      ror     temp4
000256 9527                      ror     temp3
000257 95e6                      lsr     ZL
000258 9537                      ror     temp4
000259 9527                      ror     temp3
00025a 95e6                      lsr     ZL
00025b 9537                      ror     temp4
00025c 9527                      ror     temp3
00025d 95e6                      lsr     ZL
00025e 9537                      ror     temp4
00025f 9527                      ror     temp3
000260 9320 006d                 sts     wt_comp_scan_l, temp3
000262 9330 006e                 sts     wt_comp_scan_h, temp4
                 
                         ; use the same value for commutation timing (15-)
000264 9320 006f                 sts     com_timing_l, temp3
000266 9330 0070                 sts     com_timing_h, temp4
                 
000268 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 calc_next_timing:
000269 91c0 006d                 lds     YL, wt_comp_scan_l      ; holds wait-before-scan value
00026b 91d0 006e                 lds     YH, wt_comp_scan_h
00026d df7e                      rcall   update_timing
                 
00026e 9508                      ret
                 
00026f fd70      wait_OCT1_tot:  sbrc    flags0, OCT1_PENDING
000270 cffe                      rjmp    wait_OCT1_tot
                 
000271 9837
000272 b700
000273 6008
000274 bf00      set_OCT1_tot:   AcInit
                 
000275 91d0 0074                 lds     YH, zero_wt_h
000277 91c0 0073                 lds     YL, zero_wt_l
000279 deaa                      rcall   tcnt1_to_temp
00027a 0f0c                      add     temp1, YL
00027b 1f1d                      adc     temp2, YH
00027c e035                      ldi     temp4, (1<<TOIE1)+(1<<TOIE0)
00027d bf39                      out     TIMSK, temp4
00027e bd1b                      out     OCR1AH, temp2
00027f bd0a                      out     OCR1AL, temp1
000280 6071                      sbr     flags0, (1<<OCT1_PENDING)
000281 e135                      ldi     temp4, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
000282 bf39                      out     TIMSK, temp4
000283 e430
000284 bf3b                      enable_input
000285 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 wait_OCT1_before_switch:
000286 de9d                      rcall   tcnt1_to_temp
000287 91c0 006f                 lds     YL, com_timing_l
000289 91d0 0070                 lds     YH, com_timing_h
00028b 0f0c                      add     temp1, YL
00028c 1f1d                      adc     temp2, YH
00028d e025                      ldi     temp3, (1<<TOIE1)+(1<<TOIE0)
00028e bf29                      out     TIMSK, temp3
00028f bd1b                      out     OCR1AH, temp2
000290 bd0a                      out     OCR1AL, temp1
000291 6071                      sbr     flags0, (1<<OCT1_PENDING)
000292 e125                      ldi     temp3, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
000293 bf29                      out     TIMSK, temp3
000294 e430
000295 bf3b                      enable_input
                 
                         ; don't waste time while waiting - do some controls, if indicated
000296 fd84                      sbrc    flags1, EVAL_RC_PULS
000297 de95                      rcall   evaluate_rc_puls
000298 fd85                      sbrc    flags1, EVAL_SYS_STATE
000299 deac                      rcall   evaluate_sys_state
                 
00029a fd87                      sbrc    flags1, EVAL_PWM
00029b decd                      rcall   set_new_duty
                 
00029c fd86                      sbrc    flags1, EVAL_RPM
00029d defd                      rcall   evaluate_rpm
                 
00029e fd70      OCT1_wait:      sbrc    flags0, OCT1_PENDING
00029f cffe                      rjmp    OCT1_wait
0002a0 9508                      ret
                 ;-----bko-----------------------------------------------------------------
0002a1 91c0 0071 start_timeout:  lds     YL, wt_OCT1_tot_l
0002a3 91d0 0072                 lds     YH, wt_OCT1_tot_h
0002a5 df46                      rcall   update_timing
                 
0002a6 b50c                      in      temp1, TCNT1L
0002a7 700f                      andi    temp1, 0x0f
0002a8 1bd0                      sub     YH, temp1
0002a9 3bdb                      cpi     YH, high (timeoutMIN)
0002aa f408                      brcc    set_tot2
0002ab efdd                      ldi     YH, high (timeoutSTART)         
                 set_tot2:
0002ac 93d0 0072                 sts     wt_OCT1_tot_h, YH
                 
0002ae d018                      rcall   sync_with_poweron       ; wait at least 100+ microseconds
0002af d017                      rcall   sync_with_poweron       ; for demagnetisation - one sync may be added
                 
0002b0 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 switch_power_off:
0002b1 e0f5                      ldi     ZH, MIN_DUTY-1          ; ZH is new_duty
0002b2 930f
0002b3 e005
0002b4 9500
0002b5 dea0
0002b6 910f                      SetPWMi(MIN_DUTY-1)
                 
0002b7 e000                      ldi     temp1, 0                ; reset limiter
0002b8 2ed0                      mov     sys_control, temp1
                 
0002b9 e000                      ldi     temp1, INIT_PB          ; all off
0002ba bb08                      out     PORTB, temp1
0002bb e002                      ldi     temp1, INIT_PC          ; all off
0002bc bb05                      out     PORTC, temp1
0002bd e000                      ldi     temp1, INIT_PD          ; all off
0002be bb02                      out     PORTD, temp1
                 
0002bf 6081                      sbr     flags1, (1<<POWER_OFF)  ; disable power on
0002c0 7f97                      cbr     flags2, (1<<POFF_CYCLE)
0002c1 6290                      sbr     flags2, (1<<STARTUP)
0002c2 9508                      ret                             ; motor is off
                 ;-----bko-----------------------------------------------------------------
0002c3 e008      wait_if_spike:  ldi     temp1, 4*CLK_SCALE
0002c4 950a      wait_if_spike2: dec     temp1
0002c5 f7f1                      brne    wait_if_spike2
0002c6 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 sync_with_poweron:
0002c7 fd76                      sbrc    flags0, I_OFF_CYCLE     ; first wait for power on
0002c8 cffe                      rjmp    sync_with_poweron
                 wait_for_poweroff:
0002c9 ff76                      sbrs    flags0, I_OFF_CYCLE     ; now wait for power off
0002ca cffe                      rjmp    wait_for_poweroff
0002cb 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 motor_brake:
                 .if MOT_BRAKE == 1
                 .endif  ; MOT_BRAKE == 1
0002cc 9508                      ret
                 
                 
                 wait64ms:
0002cd e002                      ldi     temp1, 1*CLK_SCALE
0002ce 2ee0                      mov     t1_timeout, temp1
                 wait120ms_wait_for_t1:    
0002cf 20ee                      tst     t1_timeout
0002d0 f7f1                      brne    wait120ms_wait_for_t1
0002d1 9508                      ret
                 
0002d2 e000      pre_align:      ldi     temp1, INIT_PB  ; all off
0002d3 bb08                      out     PORTB, temp1
0002d4 e000                      ldi     temp1, INIT_PD  ; all off
0002d5 bb02                      out     PORTD, temp1
0002d6 e002                      ldi     temp1, INIT_PC  ; all off
0002d7 bb05                      out     PORTC, temp1
0002d8 e208                      ldi     temp1, 20*CLK_SCALE
0002d9 950a      pp_FETs_off_wt: dec     temp1
0002da f7f1                      brne    pp_FETs_off_wt
0002db 7f8e                      cbr     flags1, (1<<POWER_OFF)  ; enable power
0002dc e00a                      ldi     temp1, PWR_STARTUP      ; set limiter
0002dd 2ed0                      mov     sys_control, temp1
0002de 930f
0002df e002
0002e0 9500
0002e1 de74
0002e2 910f                      SetPWMi(PWR_STARTUP*1/4);
0002e3 d16d                      rcall   com5com6
0002e4 d172                      rcall   com6com1
0002e5 dfe7                      rcall   wait64ms
0002e6 dfe6                      rcall   wait64ms
0002e7 930f
0002e8 e005
0002e9 9500
0002ea de6b
0002eb 910f                      SetPWMi(PWR_STARTUP*2/4);
0002ec dfe0                      rcall   wait64ms
0002ed 930f
0002ee e007
0002ef 9500
0002f0 de65
0002f1 910f                      SetPWMi(PWR_STARTUP*3/4);
0002f2 dfda                      rcall   wait64ms
0002f3 930f
0002f4 e00a
0002f5 9500
0002f6 de5f
0002f7 910f                      SetPWMi(PWR_STARTUP);               
0002f8 9508                      ret                
                 ;-----bko-----------------------------------------------------------------
                 ; **** startup loop ****
0002f9 dfb7      init_startup:   rcall   switch_power_off
0002fa dfd1                      rcall   motor_brake
                 wait_for_power_on:
0002fb 9ac5                      DbgLEDOn
                 
0002fc de30                      rcall   evaluate_rc_puls
0002fd 30f7                      cpi     ZH, MIN_DUTY + 1
0002fe f3e0                      brcs    wait_for_power_on
0002ff 9837
000300 b700
000301 6008
000302 bf00                      AcInit
000303 dfce                      rcall   pre_align
                 
000304 9ac5                      DbgLEDOn
                 
000305 7f9b                      cbr     flags2, (1<<SCAN_TIMEOUT)
000306 e000                      ldi     temp1, 0
000307 9300 007c                 sts     goodies, temp1
000309 e500                      ldi     temp1, 40*CLK_SCALE; x 32msec
00030a 2ee0                      mov     t1_timeout, temp1
00030b dec6                      rcall   set_all_timings
00030c df94                      rcall   start_timeout
                 ;-----bko-----------------------------------------------------------------
                 ; **** start control loop ****
                 
                 ; state 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
00030d ff94      start1:         sbrs    flags2, COMP_SAVE       ; high ?
00030e c010                      rjmp    start1_2                ; .. no - loop, while high
                 
00030f fd70      start1_0:       sbrc    flags0, OCT1_PENDING
000310 c002                      rjmp    start1_1
000311 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000312 c013                      rjmp    start1_9
000313 dfb3      start1_1:       rcall   sync_with_poweron
                 
000314 fd94                      sbrc    flags2, COMP_SAVE       ; high ?
000315 cff9                      rjmp    start1_0                ; .. no - loop, while high
                 
                 ; do the special 120- switch
000316 e000                      ldi     temp1, 0
000317 9300 007c                 sts     goodies, temp1
000319 d109                      rcall   com1com2
00031a d10e                      rcall   com2com3
00031b d11e                      rcall   com3com4
00031c de10                      rcall   evaluate_rc_puls
00031d df83                      rcall   start_timeout
00031e c031                      rjmp    start4
                         
00031f fd70      start1_2:       sbrc    flags0, OCT1_PENDING
000320 c002                      rjmp    start1_3
000321 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000322 c003                      rjmp    start1_9
000323 dfa3      start1_3:       rcall   sync_with_poweron
000324 ff94                      sbrs    flags2, COMP_SAVE       ; high ?
000325 cff9                      rjmp    start1_2                ; .. no - loop, while low
                 
                 start1_9:
000326 d0fc                      rcall   com1com2
000327 df79                      rcall   start_timeout
                 
                 ; state 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
                 
000328 fd94      start2:         sbrc    flags2, COMP_SAVE
000329 c008                      rjmp    start2_2
                 
00032a fd70      start2_0:       sbrc    flags0, OCT1_PENDING
00032b c002                      rjmp    start2_1
00032c 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
00032d c00b                      rjmp    start2_9
00032e df98      start2_1:       rcall   sync_with_poweron
00032f ff94                      sbrs    flags2, COMP_SAVE
000330 cff9                      rjmp    start2_0
000331 c007                      rjmp    start2_9
                 
000332 fd70      start2_2:       sbrc    flags0, OCT1_PENDING
000333 c002                      rjmp    start2_3
000334 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000335 c003                      rjmp    start2_9
000336 df90      start2_3:       rcall   sync_with_poweron
000337 fd94                      sbrc    flags2, COMP_SAVE
000338 cff9                      rjmp    start2_2
                 
                 start2_9:
000339 d0ef                      rcall   com2com3
00033a ddf2                      rcall   evaluate_rc_puls
00033b df65                      rcall   start_timeout
                 
                 ; state 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 
00033c ff94      start3:         sbrs    flags2, COMP_SAVE
00033d c008                      rjmp    start3_2
                 
00033e fd70      start3_0:       sbrc    flags0, OCT1_PENDING
00033f c002                      rjmp    start3_1
000340 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000341 c00b                      rjmp    start3_9
000342 df84      start3_1:       rcall   sync_with_poweron
000343 fd94                      sbrc    flags2, COMP_SAVE
000344 cff9                      rjmp    start3_0
000345 c007                      rjmp    start3_9
                 
000346 fd70      start3_2:       sbrc    flags0, OCT1_PENDING
000347 c002                      rjmp    start3_3
000348 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000349 c003                      rjmp    start3_9
00034a df7c      start3_3:       rcall   sync_with_poweron
00034b ff94                      sbrs    flags2, COMP_SAVE
00034c cff9                      rjmp    start3_2
                 
                 start3_9:
00034d d0ec                      rcall   com3com4
00034e de1a                      rcall   set_new_duty
00034f df51                      rcall   start_timeout
                 
                 ; state 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
                 
000350 fd94      start4:         sbrc    flags2, COMP_SAVE
000351 c008                      rjmp    start4_2
                 
000352 fd70      start4_0:       sbrc    flags0, OCT1_PENDING
000353 c002                      rjmp    start4_1
000354 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000355 c00b                      rjmp    start4_9
000356 df70      start4_1:       rcall   sync_with_poweron
000357 ff94                      sbrs    flags2, COMP_SAVE
000358 cff9                      rjmp    start4_0
000359 c007                      rjmp    start4_9
                 
00035a fd70      start4_2:       sbrc    flags0, OCT1_PENDING
00035b c002                      rjmp    start4_3
00035c 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
00035d c003                      rjmp    start4_9
00035e df68      start4_3:       rcall   sync_with_poweron
00035f fd94                      sbrc    flags2, COMP_SAVE
000360 cff9                      rjmp    start4_2
                 
                 start4_9:
000361 d0de                      rcall   com4com5
000362 df3e                      rcall   start_timeout
                 
                 
                 ; state 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
                 
                 
000363 ff94      start5:         sbrs    flags2, COMP_SAVE
000364 c008                      rjmp    start5_2
                 
000365 fd70      start5_0:       sbrc    flags0, OCT1_PENDING
000366 c002                      rjmp    start5_1
000367 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000368 c00b                      rjmp    start5_9
000369 df5d      start5_1:       rcall   sync_with_poweron
00036a fd94                      sbrc    flags2, COMP_SAVE
00036b cff9                      rjmp    start5_0
00036c c007                      rjmp    start5_9
                 
00036d fd70      start5_2:       sbrc    flags0, OCT1_PENDING
00036e c002                      rjmp    start5_3
00036f 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000370 c003                      rjmp    start5_9
000371 df55      start5_3:       rcall   sync_with_poweron
000372 ff94                      sbrs    flags2, COMP_SAVE
000373 cff9                      rjmp    start5_2
                 
                 start5_9:
000374 d0dc                      rcall   com5com6
000375 ddd0                      rcall   evaluate_sys_state
000376 df2a                      rcall   start_timeout
                 
                 ; state 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
                 
000377 fd94      start6:         sbrc    flags2, COMP_SAVE
000378 c008                      rjmp    start6_2
                 
000379 fd70      start6_0:       sbrc    flags0, OCT1_PENDING
00037a c002                      rjmp    start6_1
00037b 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
00037c c00b                      rjmp    start6_9
00037d df49      start6_1:       rcall   sync_with_poweron
00037e ff94                      sbrs    flags2, COMP_SAVE
00037f cff9                      rjmp    start6_0
000380 c007                      rjmp    start6_9
                 
000381 fd70      start6_2:       sbrc    flags0, OCT1_PENDING
000382 c002                      rjmp    start6_3
000383 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000384 c003                      rjmp    start6_9
000385 df41      start6_3:       rcall   sync_with_poweron
000386 fd94                      sbrc    flags2, COMP_SAVE
000387 cff9                      rjmp    start6_2
                 
                 start6_9:
000388 d0ce                      rcall   com6com1
                 
000389 2d02                      mov     temp1, tcnt0_power_on
00038a 3f0a                      cpi     temp1, NO_POWER
00038b f409                      brne    s6_power_ok
00038c cf6c                      rjmp    init_startup
                 
00038d 20ee      s6_power_ok:    tst     t1_timeout
00038e f409                      brne    s6_test_rpm
00038f cf69                      rjmp    init_startup            ;-) demich
                                 
000390 9100 0066 s6_test_rpm:    lds     temp1, timing_x
000392 2300                      tst     temp1
000393 f421                      brne    s6_goodies
000394 9100 0065                 lds     temp1, timing_h         ; get actual RPM reference high
                 ;               cpi     temp1, PWR_RANGE1*CLK_SCALE
000396 3400                      cpi     temp1, PWR_RANGE2*CLK_SCALE
000397 f050                      brcs    s6_run1
                 
000398 9100 007c s6_goodies:     lds     temp1, goodies
00039a fd92                      sbrc    flags2, SCAN_TIMEOUT
00039b 2700                      clr     temp1
00039c 9503                      inc     temp1
00039d 9300 007c                 sts     goodies,  temp1
00039f 7f9b                      cbr     flags2, (1<<SCAN_TIMEOUT)
0003a0 330c                      cpi     temp1, ENOUGH_GOODIES
0003a1 f038                      brcs    s6_start1       
                 
0003a2 ef0f      s6_run1:        ldi     temp1, 0xff
0003a3 2ef0                      mov     run_control, temp1
                 
0003a4 dec4                      rcall   calc_next_timing
0003a5 decb                      rcall   set_OCT1_tot
                 
0003a6 98c5                      DbgLEDOff
                 
0003a7 7d9f                      cbr     flags2, (1<<STARTUP)
0003a8 c002                      rjmp    run1                    ; running state begins
                 
0003a9 def7      s6_start1:      rcall   start_timeout           ; need to be here for a correct temp1=comp_state
0003aa cf62                      rjmp    start1                  ; go back to state 1
                 
                 ;-----bko-----------------------------------------------------------------
                 ; **** running control loop ****
                 
                 ; run 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
                 
0003ab d059      run1:           rcall   wait_for_low
0003ac ff70                      sbrs    flags0, OCT1_PENDING
0003ad c043                      rjmp    run_to_start
0003ae d065                      rcall   wait_for_high
0003af ff70                      sbrs    flags0, OCT1_PENDING
0003b0 c040                      rjmp    run_to_start
0003b1 6480                      sbr     flags1, (1<<EVAL_RPM)
0003b2 ded3                      rcall   wait_OCT1_before_switch
0003b3 d06f                      rcall   com1com2
0003b4 deb4                      rcall   calc_next_timing
0003b5 deb9                      rcall   wait_OCT1_tot
                                 
                 ; run 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
                 
0003b6 d05d      run2:           rcall   wait_for_high
0003b7 ff70                      sbrs    flags0, OCT1_PENDING
0003b8 c038                      rjmp    run_to_start
0003b9 d04b                      rcall   wait_for_low
0003ba ff70                      sbrs    flags0, OCT1_PENDING
0003bb c035                      rjmp    run_to_start
0003bc 6180                      sbr     flags1, (1<<EVAL_RC_PULS)
0003bd dec8                      rcall   wait_OCT1_before_switch
0003be d06a                      rcall   com2com3
0003bf dea9                      rcall   calc_next_timing
0003c0 deae                      rcall   wait_OCT1_tot
                 
                 ; run 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 
0003c1 d043      run3:           rcall   wait_for_low
0003c2 ff70                      sbrs    flags0, OCT1_PENDING
0003c3 c02d                      rjmp    run_to_start
0003c4 d04f                      rcall   wait_for_high
0003c5 ff70                      sbrs    flags0, OCT1_PENDING
0003c6 c02a                      rjmp    run_to_start
0003c7 6880                      sbr     flags1, (1<<EVAL_PWM)
0003c8 debd                      rcall   wait_OCT1_before_switch
0003c9 d070                      rcall   com3com4
0003ca de9e                      rcall   calc_next_timing
0003cb dea3                      rcall   wait_OCT1_tot
                 
                 ; run 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
0003cc d047      run4:           rcall   wait_for_high
0003cd ff70                      sbrs    flags0, OCT1_PENDING
0003ce c022                      rjmp    run_to_start
0003cf d035                      rcall   wait_for_low
0003d0 ff70                      sbrs    flags0, OCT1_PENDING
0003d1 c01f                      rjmp    run_to_start
0003d2 deb3                      rcall   wait_OCT1_before_switch
0003d3 d06c                      rcall   com4com5
0003d4 de94                      rcall   calc_next_timing
0003d5 de99                      rcall   wait_OCT1_tot
                 
                 ; run 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
                 
0003d6 d02e      run5:           rcall   wait_for_low
0003d7 ff70                      sbrs    flags0, OCT1_PENDING
0003d8 c018                      rjmp    run_to_start
0003d9 d03a                      rcall   wait_for_high
0003da ff70                      sbrs    flags0, OCT1_PENDING
0003db c015                      rjmp    run_to_start
0003dc 6280                      sbr     flags1, (1<<EVAL_SYS_STATE)
0003dd dea8                      rcall   wait_OCT1_before_switch
0003de d072                      rcall   com5com6
0003df de89                      rcall   calc_next_timing
0003e0 de8e                      rcall   wait_OCT1_tot
                 
                 ; run 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
                 
0003e1 d032      run6:           rcall   wait_for_high
0003e2 ff70                      sbrs    flags0, OCT1_PENDING
0003e3 c00d                      rjmp    run_to_start
0003e4 d020                      rcall   wait_for_low
0003e5 ff70                      sbrs    flags0, OCT1_PENDING
0003e6 c00a                      rjmp    run_to_start
0003e7 de9e                      rcall   wait_OCT1_before_switch
0003e8 d06e                      rcall   com6com1
0003e9 de7f                      rcall   calc_next_timing
0003ea de84                      rcall   wait_OCT1_tot
                 
                 ;               rjmp    run6_2
                 
0003eb 9100 0066                 lds     temp1, timing_x
0003ed 2300                      tst     temp1
0003ee f039                      breq    run6_2                  ; higher than 610 RPM if zero
                 .if CLK_SCALE==2                                
0003ef 950a                      dec     temp1
0003f0 f029                      breq    run6_2                  ; higher than 610 RPM if equ 1
                 .endif                
0003f1 6290      run_to_start:   sbr     flags2, (1<<STARTUP)
0003f2 7f97                      cbr     flags2, (1<<POFF_CYCLE)
0003f3 ff80                      sbrs    flags1, POWER_OFF
0003f4 c00d                      rjmp    restart_control
0003f5 cf05                      rjmp    wait_for_power_on
                 
0003f6 7f97      run6_2:         cbr     flags2, (1<<POFF_CYCLE)
0003f7 20ff                      tst     run_control             ; only once !
0003f8 f041                      breq    run6_9
0003f9 94fa                      dec     run_control
0003fa f029                      breq    run6_3                  ; poweroff if 0
0003fb 2d0f                      mov     temp1, run_control
0003fc 3001                      cpi     temp1, 1                ; poweroff if 1
0003fd f011                      breq    run6_3
0003fe 3002                      cpi     temp1, 2                ; poweroff if 2
0003ff f409                      brne    run6_9
000400 6098      run6_3:         sbr     flags2, (1<<POFF_CYCLE)
                 
                 run6_9:
000401 cfa9                      rjmp    run1                    ; go back to run 1
                 
                 restart_control:
000402 94f8                      cli                             ; disable all interrupts
000403 dead                      rcall   switch_power_off
000404 cc19                      rjmp    reset
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; *** scan comparator utilities ***
                 .macro __wait_for_filter
                                 clc
                                 sbis    ACSR, ACO
                                 sec
                                 brcc    wait_for_filter_1
                                 inc     temp2
                 wait_for_filter_1:
                                 rol     temp1
                                 brcc    wait_for_filter_2
                                 dec     temp2
                 wait_for_filter_2:
                 .endmacro
                                                 
                 wait_for_low:   
000405 ef0f                      ldi     temp1, 0xFF
000406 e018                      ldi     temp2, 8
                 wait_for_low_loop:
000407 ff70                      sbrs    flags0, OCT1_PENDING
000408 9508                      ret
000409 9488
00040a 9b45
00040b 9408
00040c f408
00040d 9513
00040e 1f00
00040f f408
000410 951a                      __wait_for_filter
000411 3012                      cpi     temp2, (8-7) + 1
000412 f7a0                      brcc    wait_for_low_loop
000413 9508                      ret
                                                
                 wait_for_high:   
000414 e000                      ldi     temp1, 0x0
000415 e010                      ldi     temp2, 0
                 wait_for_high_loop:
000416 ff70                      sbrs    flags0, OCT1_PENDING
000417 9508                      ret
000418 9488
000419 9b45
00041a 9408
00041b f408
00041c 9513
00041d 1f00
00041e f408
00041f 951a                      __wait_for_filter
000420 3017                      cpi     temp2, 7
000421 f3a0                      brcs    wait_for_high_loop
000422 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 ; *** commutation utilities ***
000423 98ad      com1com2:       BpFET_off                             ; Bp off
000424 ff80                      sbrs    flags1, POWER_OFF
000425 9a94                      ApFET_on                              ; Ap on
000426 e007
000427 b907                      AcPhaseB
000428 9508                      ret
                 
000429 e104      com2com3:       ldi     temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
00042a bf09                      out     TIMSK, temp1                  ;  .. only ONE should change these values at the time
00042b 0000                      nop
00042c 7d7f                      cbr     flags0, (1<<A_FET)            ; next nFET = BnFET
00042d 7e7f                      cbr     flags0, (1<<C_FET)
00042e fd81                      sbrc    flags1, FULL_POWER
00042f c002                      rjmp    c2_switch
000430 fd76                      sbrc    flags0, I_OFF_CYCLE           ; was power off ?
000431 c003                      rjmp    c2_done                       ; .. yes - futhermore work is done in timer0 interrupt
000432 98c0      c2_switch:      CnFET_off                             ; Cn off
000433 ff80                      sbrs    flags1, POWER_OFF
000434 9aac                      BnFET_on                              ; Bn on
000435 e105      c2_done:        ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
000436 bf09                      out     TIMSK, temp1
000437 e000
000438 b907                      AcPhaseC
000439 9508                      ret
                 
00043a 9894      com3com4:       ApFET_off                             ; Ap off
00043b ff80                      sbrs    flags1, POWER_OFF
00043c 9aab                      CpFET_on                              ; Cp on
00043d e006
00043e b907                      AcPhaseA
00043f 9508                      ret
                 
000440 e104      com4com5:       ldi     temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
000441 bf09                      out     TIMSK, temp1                  ;  .. only ONE should change these values at the time
000442 0000                      nop
000443 6270                      sbr     flags0, (1<<A_FET)            ; next nFET = AnFET
000444 7e7f                      cbr     flags0, (1<<C_FET)
000445 fd81                      sbrc    flags1, FULL_POWER
000446 c002                      rjmp    c4_switch
000447 fd76                      sbrc    flags0, I_OFF_CYCLE           ; was power off ?
000448 c003                      rjmp    c4_done                       ; .. yes - futhermore work is done in timer0 interrupt
000449 98ac      c4_switch:      BnFET_off                             ; Bn off
00044a ff80                      sbrs    flags1, POWER_OFF
00044b 9a95                      AnFET_on                              ; An on
00044c e105      c4_done:        ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
00044d bf09                      out     TIMSK, temp1
00044e e007
00044f b907                      AcPhaseB
000450 9508                      ret
                 
000451 98ab      com5com6:       CpFET_off                             ; Cp off
000452 ff80                      sbrs    flags1, POWER_OFF
000453 9aad                      BpFET_on                              ; Bp on
000454 e000
000455 b907                      AcPhaseC
000456 9508                      ret
                 
000457 e104      com6com1:       ldi     temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
000458 bf09                      out     TIMSK, temp1                  ;  .. only ONE should change these values at the time
000459 0000                      nop
00045a 7d7f                      cbr     flags0, (1<<A_FET)            ; next nFET = CnFET
00045b 6170                      sbr     flags0, (1<<C_FET)
00045c fd81                      sbrc    flags1, FULL_POWER
00045d c002                      rjmp    c6_switch
00045e fd76                      sbrc    flags0, I_OFF_CYCLE           ; was power off ?
00045f c003                      rjmp    c6_done                       ; .. yes - futhermore work is done in timer0 interrupt
000460 9895      c6_switch:      AnFET_off                             ; An off
000461 ff80                      sbrs    flags1, POWER_OFF
000462 9ac0                      CnFET_on                              ; Cn on
000463 e105      c6_done:        ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
000464 bf09                      out     TIMSK, temp1
000465 e006
000466 b907                      AcPhaseA
000467 9508                      ret
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega8 register use summary:
r0 :   0 r1 :   9 r2 :   4 r3 :   0 r4 :   0 r5 :   0 r6 :   3 r7 :   2 
r8 :   2 r9 :   0 r10:   0 r11:   6 r12:   5 r13:   6 r14:   6 r15:   4 
r16: 232 r17:  66 r18:  54 r19:  48 r20:  26 r21:  11 r22:  12 r23:  53 
r24:  37 r25:  54 r26:   2 r27:   1 r28:  11 r29:  15 r30:  17 r31:   5 
x  :   1 y  :   0 z  :   0 
Registers used: 27 out of 35 (77.1%)

ATmega8 instruction use summary:
adc   :   9 add   :   6 adiw  :   0 and   :   0 andi  :   1 asr   :   0 
bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 brcc  :  11 brcs  :  12 
breq  :  13 brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 
brlo  :   4 brlt  :   0 brmi  :   0 brne  :  22 brpl  :   0 brsh  :   4 
brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 bst   :   0 
cbi   :  14 cbr   :  27 clc   :   2 clh   :   0 cli   :   4 cln   :   0 
clr   :  13 cls   :   0 clt   :   0 clv   :   0 clz   :   0 com   :   8 
cp    :   6 cpc   :   4 cpi   :  29 cpse  :   0 dec   :  17 eor   :   0 
fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :  18 
inc   :   7 ld    :   0 ldd   :   0 ldi   : 106 lds   :  44 lpm   :   0 
lsl   :   0 lsr   :  11 mov   :  27 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   8 or    :   0 ori   :   0 out   :  65 
pop   :   6 push  :   6 rcall : 116 ret   :  32 reti  :  19 rjmp  : 114 
rol   :   2 ror   :  19 sbc   :   5 sbci  :   4 sbi   :  13 sbic  :   2 
sbis  :   3 sbiw  :   0 sbr   :  39 sbrc  :  39 sbrs  :  39 sec   :   2 
seh   :   0 sei   :   3 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   1 std   :   0 
sts   :  47 sub   :   6 subi  :   4 swap  :   0 tst   :  13 wdr   :   0 

Instructions used: 50 out of 108 (46.3%)

ATmega8 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0008d0   2234     22   2256    8192  27.5%
[.dseg] 0x000060 0x0000e3      0    131    131    1024  12.8%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
