
AVRASM ver. 2.1.12  core\bldc.asm Wed Sep 28 14:00:42 2011

[builtin](2): Including file 'core\..\input\pwm_rc_200.inc'
core\..\input\pwm_rc_200.inc(1): Including file 'core\ppm.inc'
[builtin](3): Including file 'core\..\hw\Plush30A.inc'
core\..\hw\Plush30A.inc(1): Including file 'core\common.inc'
core\bldc.asm(20): Including file 'C:\Program Files (x86)\AvrAssembler2\AppNotes\m8def.inc'
                 
                 ;**** **** **** **** ****
                 
                 
                 .equ    EXT0_EN    = 0x40       ; enable ext0int
                 
                 #define __ext_int0  rjmp ext_int0_isr
                 .macro __ext_int0_isr
                   __ext_micp_isr
                 .endmacro
                 
                 ;-----bko-----------------------------------------------------------------
                 ; external interrupt0 = rc pulse input
                 .macro __ext_micp_isr
                                 in      i_sreg, SREG
                 
                 ; evaluate edge of this interrupt
                                 in      i_temp1, MCUCR
                                 sbrs    i_temp1, ISC00
                                 rjmp    falling_edge                              ; bit is clear = falling edge
                 
                 ; should be rising edge - test rc impuls level state for possible jitter
                                 sbis    PIND, rcp_in
                                 rjmp    extint1_exit                              ; jump, if low state
                 
                 ; rc impuls is at high state
                                 ldi     i_temp1, (1<<ISC01)
                                 out     MCUCR, i_temp1                            ; set next int0 to falling edge
                 
                 ; get timer1 values
                                 in      i_temp1, TCNT1L
                                 in      i_temp2, TCNT1H
                                 mov     start_rcpuls_l, i_temp1
                                 mov     start_rcpuls_h, i_temp2
                 ; test rcpulse interval
                                 cbr     flags2, (1<<RC_INTERVAL_OK)               ; preset to not ok
                                 lds     i_temp3, stop_rcpuls_l
                                 sub     i_temp1, i_temp3
                                 lds     i_temp3, stop_rcpuls_h
                                 sbc     i_temp2, i_temp3
                                 cpi     i_temp1, low (MAX_INT_FR*CLK_SCALE)
                                 ldi     i_temp3, high(MAX_INT_FR*CLK_SCALE)       ; test range high
                                 cpc     i_temp2, i_temp3
                                 brsh    extint1_fail                              ; through away
                                 cpi     i_temp1, low (MIN_INT_FR*CLK_SCALE)
                                 ldi     i_temp3, high(MIN_INT_FR*CLK_SCALE)       ; test range low
                                 cpc     i_temp2, i_temp3
                                 brlo    extint1_fail                              ; through away
                                 sbr     flags2, (1<<RC_INTERVAL_OK)               ; set to rc impuls value is ok !
                                 rjmp    extint1_exit
                 extint1_fail:   tst     control_timeout
                                 breq    extint1_exit
                                 dec     control_timeout
                                 rjmp    extint1_exit
                                 ; rc impuls is at low state
                 falling_edge:   sbic    PIND, rcp_in                              ; test level of rc impuls
                                 rjmp    extint1_exit                              ; seems to be a spike
                                 ldi     i_temp1, (1<<ISC01)+(1<<ISC00)
                                 out     MCUCR, i_temp1                            ; set next int0 to rising edge
                                 sbrc    flags1, RC_PULS_UPDATED
                                 rjmp    extint1_exit
                                 ; get timer1 values
                                 in      i_temp1, TCNT1L
                                 in      i_temp2, TCNT1H
                                 sts     stop_rcpuls_l, i_temp1                    ; prepare next interval evaluation
                                 sts     stop_rcpuls_h, i_temp2
                                 sbrs    flags2, RC_INTERVAL_OK
                                 rjmp    extint1_exit
                                 cbr     flags2, (1<<RC_INTERVAL_OK)               ; flag is evaluated
                                 sub     i_temp1, start_rcpuls_l
                                 sbc     i_temp2, start_rcpuls_h
                                 ; save impuls length
                                 sts     new_rcpuls_l, i_temp1
                                 sts     new_rcpuls_h, i_temp2
                                 cpi     i_temp1, low (MAX_INT_RF*CLK_SCALE)
                                 ldi     i_temp3, high(MAX_INT_RF*CLK_SCALE)       ; test range high
                                 cpc     i_temp2, i_temp3
                                 brsh    extint1_fail                              ; through away
                                 cpi     i_temp1, low (MIN_INT_RF*CLK_SCALE)
                                 ldi     i_temp3, high(MIN_INT_RF*CLK_SCALE)       ; test range low
                                 cpc     i_temp2, i_temp3
                                 brlo    extint1_fail                              ; through away
                                 sbr     flags1, (1<<RC_PULS_UPDATED)              ; set to rc impuls value is ok !
                                 ldi     i_temp1, CONTROL_TOT*CLK_SCALE
                                 mov     control_timeout, i_temp1
                                 ; enable int1 again -  also entry for spike detect
                 extint1_exit:   
                                 out     SREG, i_sreg
                                 reti
                 .endm
                 
                 .macro enable_input
                                 ldi     temp4, EXT0_EN                            ; ext0int enable
                                 out     GIMSK, temp4                              ; enable ext0int
                 .endm 
                 
                 .macro disable_input
                                 ldi     temp4, EXT0_DIS                           ; disable ext0int
                                 out     GIMSK, temp4
                 .endm 
                 
                 .macro init_input
                                 ldi     temp1, (1<<ISC01)+(1<<ISC00)
                                 out     MCUCR, temp1                              ; set next int0 to rising edge
                                 enable_input
                 .endm
                 
                 .equ    POWER_RANGE   = 200
                 .equ    MIN_RC_PULS   = 1100
                 
                 ; falling->rising intervals
                 .equ    MAX_INT_FR    = 25000
                 .equ    MIN_INT_FR    = 15000
                 
                 ; rising->falling intervals
                 .equ    MAX_INT_RF    = 2200
                 .equ    MIN_INT_RF    = 800
                 
                 .macro EvaluatePWC
                                 cbr     flags1, (1<<EVAL_RC_PULS)
                                 sbrs    flags1, RC_PULS_UPDATED
                                 rjmp    eval_rc_p90
                                 lds     temp1, new_rcpuls_l
                                 lds     temp2, new_rcpuls_h
                                 cbr     flags1, (1<<RC_PULS_UPDATED) ; rc impuls value is read out
                                 subi    temp1, low  (MIN_RC_PULS*CLK_SCALE)
                                 sbci    temp2, high (MIN_RC_PULS*CLK_SCALE)
                                 brcc    eval_rc_p00
                                 clr     temp1
                                 clr     temp2
                 eval_rc_p00:    lsr     temp2
                                 ror     temp1
                                 lsr     temp2
                                 ror     temp1
                 .if CLK_SCALE==2
                                 lsr     temp2   ; actual 0->400
                                 ror     temp1
                 .endif
                                 mov     temp3, temp1            
                                 subi    temp1, POWER_RANGE
                                 brcs    eval_rc_p10
                                 ldi     temp3, POWER_RANGE
                 eval_rc_p10:    mov     ZH, temp3
                 eval_rc_p90:    ret
                 
                 .endmacro
                 ;Die Benutzung der Software ist mit folgenden Bedingungen verbunden:
                 
                 
                   cbi     ADCSRA, ADEN          ; disable ADC
                   in      temp1, SFIOR
                   sbr     temp1, (1<<ACME)      ; switch to comparator multiplexed
                   out     SFIOR, temp1
                 .endmacro  
                 
                 .macro ACNormal
                    cbr  temp1, (1<<ACME)        ; set to AN1
                    out  SFIOR, temp1
                    sbi  ADCSRA, ADEN            ; enable ADC
                 .endmacro  
                 
                 .macro ACChannel 
                    ldi   temp1, @0              
                    out   ADMUX, temp1
                 .endmacro  
                 
                 #define Typ "Plush 30"
                 
                 ;**** **** **** **** ****
                 ; PORT  definitions
                 ;**** **** **** **** ****
                 
                 ;*********************
                 ; PORT D 
                 ;*********************  
                 .equ    mux_c           = 7     ;i <plus> comparator input (AIN0)
                 .equ    c_comp          = 6     ;i common comparator input (AIN0)
                 .equ    ApFET           = 5     ;o
                 .equ    BpFET           = 4     ;o
                 .equ    CpFET           = 3     ;o
                 .equ    rcp_in          = 2     ;i r/c pulse input
                 
                 .equ    INIT_PD         = 0
                 .equ    DIR_PD          = (1<<ApFET)+(1<<BpFET)+(1<<CpFET)
                 .equ    BRAKE_PD        = 0
                 
                 #define ApFET_on        sbi     PORTD,5
                 #define ApFET_off       cbi     PORTD,5
                 #define BpFET_on        sbi     PORTD,4
                 #define BpFET_off       cbi     PORTD,4
                 #define CpFET_on        sbi     PORTD,3
                 #define CpFET_off       cbi     PORTD,3
                 
                 
                 ;*********************
                 ; PORT C definitions *
                 ;*********************
                 .equ    mux_a           = 5     ; ADC5 phase input
                 .equ    mux_b           = 4     ; ADC4 phase input
                 ;.equ                   = 3     ; ADC3
                 ;.equ                   = 2     ; ADC2
                 .equ    temp_adc        = 1     ; ADC1 temperature control input 
                 .equ    accu_adc        = 0     ; ADC0 voltage control input 
                 
                 ;*********************
                 ; ADC only
                 ;*********************
                 ;.equ                   = 7     ; ADC7
                 ;.equ                   = 6     ; ADC6
                 
                 .equ    INIT_PC         = 0
                 .equ    DIR_PC          = 0
                 .equ    BRAKE_PC        = 0
                 
                 
                 ;*********************
                 ; PORT B definitions *
                 ;*********************
                 ;.equ           = 7     
                 ;.equ           = 6     
                 .equ    DbgLED  = 5;    (sck stk200 interface) 
                 ;.equ           = 4     (miso stk200 interface)
                 ;.equ           = 3     (mosi stk200 interface) 
                 ;.equ           = 2     
                 ;.equ           = 1     
                 ;.equ           = 0
                 
                 .equ    AnFET           = 2     ;o
                 .equ    BnFET           = 1     ;o
                 .equ    CnFET           = 0     ;o
                 
                 .equ    INIT_PB         = 0
                 .equ    DIR_PB          = (1<<AnFET)+(1<<BnFET)+(1<<CnFET)+(1<<DbgLED)
                 .equ    BRAKE_PB        = (1<<AnFET)+(1<<BnFET)+(1<<CnFET)
                 
                 #define AnFET_on        sbi     PORTB,2
                 #define AnFET_off       cbi     PORTB,2
                 #define BnFET_on        sbi     PORTB,1
                 #define BnFET_off       cbi     PORTB,1
                 #define CnFET_on        sbi     PORTB,0
                 #define CnFET_off       cbi     PORTB,0
                 
                 #define DbgLEDOn        sbi     PORTB,5
                 #define DbgLEDOff       cbi     PORTB,5
                 
                 ;*************************
                 ; Comparator definitions *
                 ;*************************
                 
                 .macro AcInit
                 .endmacro
                 
                 
                 .macro AcPhaseA
                   ACChannel mux_a
                   ACMultiplexed
                 .endmacro
                 
                 
                 .macro AcPhaseB
                   ACChannel mux_b
                   ACMultiplexed
                 .endmacro
                 
                 
                 .macro AcPhaseC
                   ACNormal
                 .endmacro
                 
                 
                 ;*************************
                 ; Parameters             *
                 ;*************************
                 .equ MOT_BRAKE        = 0
                 .equ CLK_SCALE        = 1                       ; 8Mhz internal RC oscilator 
                 .equ READ_CALIBRATION = 1                       ; Calibrated  
                 
                 ;*************************
                 ; Timings                *
                 ;*************************
                 .equ    MIN_DUTY        = 3*POWER_RANGE/100     ; Min power 3%
                 
                 .equ    PWR_MAX_RPM1    = POWER_RANGE/4
                 .equ    PWR_MAX_RPM2    = POWER_RANGE/2
                 
                 .equ    PWR_STARTUP     = 5*POWER_RANGE/100     ;  5%
                 .equ    PWR_MAX_STARTUP = 12*POWER_RANGE/100    ; 15%
                 
                 .equ    timeoutSTART    = 48000
                 .equ    timeoutMIN      = 36000
                 
                 .equ    PWR_RANGE1      = 0x40      ; ( ~2400 RPM )
                 .equ    PWR_RANGE2      = 0x20
                 
                 .equ    ENOUGH_GOODIES  = 60
                 
                 ;
                 ;Die Benutzung der Software ist mit folgenden Bedingungen verbunden:
                 ;
                 ;1. Da ich alles kostenlos zur Verfügung stelle, gebe ich keinerlei Garantie
                 ;   und übernehme auch keinerlei Haftung für die Folgen der Benutzung.
                 ;
                 ;2. Die Software ist ausschließlich zur privaten Nutzung bestimmt. Ich
                 ;   habe nicht geprüft, ob bei gewerblicher Nutzung irgendwelche Patentrechte
                 ;   verletzt werden oder sonstige rechtliche Einschränkungen vorliegen.
                 ;
                 ;3. Jeder darf Änderungen vornehmen, z.B. um die Funktion seinen Bedürfnissen
                 ;   anzupassen oder zu erweitern. Ich würde mich freuen, wenn ich weiterhin als
                 ;   Co-Autor in den Unterlagen erscheine und mir ein Link zur entprechenden Seite
                 ;   (falls vorhanden) mitgeteilt wird.
                 ;
                 ;4. Auch nach den Änderungen sollen die Software weiterhin frei sein, d.h. kostenlos bleiben.
                 ;
                 ;!! Wer mit den Nutzungbedingungen nicht einverstanden ist, darf die Software nicht nutzen !!
                 .include "m8def.inc"
                 
                 ;***** Created: 2007-02-28 07:32 ******* Source: ATmega8.xml *************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m8def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega8
                 ;* Date              : 2007-02-28
                 ;* Version           : 2.24
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega8
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M8DEF_INC_
                 #define _M8DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega8
                 #pragma AVRPART ADMIN PART_NAME ATmega8
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x93
                 .equ	SIGNATURE_002	= 0x07
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	GICR	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCR	= 0x37
                 .equ	TWCR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUCSR	= 0x34
                 .equ	TCCR0	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	SFIOR	= 0x30
                 .equ	TCCR1A	= 0x2f
                 .equ	TCCR1B	= 0x2e
                 .equ	TCNT1L	= 0x2c
                 .equ	TCNT1H	= 0x2d
                 .equ	OCR1AL	= 0x2a
                 .equ	OCR1AH	= 0x2b
                 .equ	OCR1BL	= 0x28
                 .equ	OCR1BH	= 0x29
                 .equ	ICR1L	= 0x26
                 .equ	ICR1H	= 0x27
                 .equ	TCCR2	= 0x25
                 .equ	TCNT2	= 0x24
                 .equ	OCR2	= 0x23
                 .equ	ASSR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	UBRRH	= 0x20
                 .equ	UCSRC	= 0x20
                 .equ	EEARL	= 0x1e
                 .equ	EEARH	= 0x1f
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PORTC	= 0x15
                 .equ	DDRC	= 0x14
                 .equ	PINC	= 0x13
                 .equ	PORTD	= 0x12
                 .equ	DDRD	= 0x11
                 .equ	PIND	= 0x10
                 .equ	SPDR	= 0x0f
                 .equ	SPSR	= 0x0e
                 .equ	SPCR	= 0x0d
                 .equ	UDR	= 0x0c
                 .equ	UCSRA	= 0x0b
                 .equ	UCSRB	= 0x0a
                 .equ	UBRRL	= 0x09
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCL	= 0x04
                 .equ	ADCH	= 0x05
                 .equ	TWDR	= 0x03
                 .equ	TWAR	= 0x02
                 .equ	TWSR	= 0x01
                 .equ	TWBR	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; SFIOR - Special Function IO Register
                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; GICR - General Interrupt Control Register
                 .equ	GIMSK	= GICR	; For compatibility
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                 
                 ; GIFR - General Interrupt Flag Register
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 .equ	INTF1	= 7	; External Interrupt Flag 1
                 
                 ; MCUCR - MCU Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 
                 ; TCCR0 - Timer/Counter0 Control Register
                 .equ	CS00	= 0	; Clock Select0 bit 0
                 .equ	CS01	= 1	; Clock Select0 bit 1
                 .equ	CS02	= 2	; Clock Select0 bit 2
                 
                 ; TCNT0 - Timer Counter 0
                 .equ	TCNT00	= 0	; Timer Counter 0 bit 0
                 .equ	TCNT01	= 1	; Timer Counter 0 bit 1
                 .equ	TCNT02	= 2	; Timer Counter 0 bit 2
                 .equ	TCNT03	= 3	; Timer Counter 0 bit 3
                 .equ	TCNT04	= 4	; Timer Counter 0 bit 4
                 .equ	TCNT05	= 5	; Timer Counter 0 bit 5
                 .equ	TCNT06	= 6	; Timer Counter 0 bit 6
                 .equ	TCNT07	= 7	; Timer Counter 0 bit 7
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	FOC1B	= 2	; Force Output Compare 1B
                 .equ	FOC1A	= 3	; Force Output Compare 1A
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	CTC1	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                 .equ	OCF2	= 7	; Output Compare Flag 2
                 
                 ; TCCR2 - Timer/Counter2 Control Register
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM21	= 3	; Waveform Generation Mode
                 .equ	CTC2	= WGM21	; For compatibility
                 .equ	COM20	= 4	; Compare Output Mode bit 0
                 .equ	COM21	= 5	; Compare Output Mode bit 1
                 .equ	WGM20	= 6	; Waveform Genration Mode
                 .equ	PWM2	= WGM20	; For compatibility
                 .equ	FOC2	= 7	; Force Output Compare
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2 - Timer/Counter2 Output Compare Register
                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                 
                 
                 ; ***** USART ************************
                 ; UDR - USART I/O Data Register
                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSRA - USART Control and Status Register A
                 .equ	USR	= UCSRA	; For compatibility
                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                 .equ	U2X	= 1	; Double the USART transmission speed
                 .equ	UPE	= 2	; Parity Error
                 .equ	PE	= UPE	; For compatibility
                 .equ	DOR	= 3	; Data overRun
                 .equ	FE	= 4	; Framing Error
                 .equ	UDRE	= 5	; USART Data Register Empty
                 .equ	TXC	= 6	; USART Transmitt Complete
                 .equ	RXC	= 7	; USART Receive Complete
                 
                 ; UCSRB - USART Control and Status Register B
                 .equ	UCR	= UCSRB	; For compatibility
                 .equ	TXB8	= 0	; Transmit Data Bit 8
                 .equ	RXB8	= 1	; Receive Data Bit 8
                 .equ	UCSZ2	= 2	; Character Size
                 .equ	CHR9	= UCSZ2	; For compatibility
                 .equ	TXEN	= 3	; Transmitter Enable
                 .equ	RXEN	= 4	; Receiver Enable
                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSRC - USART Control and Status Register C
                 .equ	UCPOL	= 0	; Clock Polarity
                 .equ	UCSZ0	= 1	; Character Size
                 .equ	UCSZ1	= 2	; Character Size
                 .equ	USBS	= 3	; Stop Bit Select
                 .equ	UPM0	= 4	; Parity Mode Bit 0
                 .equ	UPM1	= 5	; Parity Mode Bit 1
                 .equ	UMSEL	= 6	; USART Mode Select
                 .equ	URSEL	= 7	; Register Select
                 
                 .equ	UBRRHI	= UBRRH	; For compatibility
                 
                 ; ***** TWI **************************
                 ; TWBR - TWI Bit Rate register
                 .equ	I2BR	= TWBR	; For compatibility
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	I2CR	= TWCR	; For compatibility
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	I2IE	= TWIE	; For compatibility
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	I2EN	= TWEN	; For compatibility
                 .equ	ENI2C	= TWEN	; For compatibility
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	I2WC	= TWWC	; For compatibility
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	I2STO	= TWSTO	; For compatibility
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	I2STA	= TWSTA	; For compatibility
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	I2EA	= TWEA	; For compatibility
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 .equ	I2INT	= TWINT	; For compatibility
                 
                 ; TWSR - TWI Status Register
                 .equ	I2SR	= TWSR	; For compatibility
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWS0	= TWPS0	; For compatibility
                 .equ	I2GCE	= TWPS0	; For compatibility
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS1	= TWPS1	; For compatibility
                 .equ	TWS3	= 3	; TWI Status
                 .equ	I2S3	= TWS3	; For compatibility
                 .equ	TWS4	= 4	; TWI Status
                 .equ	I2S4	= TWS4	; For compatibility
                 .equ	TWS5	= 5	; TWI Status
                 .equ	I2S5	= TWS5	; For compatibility
                 .equ	TWS6	= 6	; TWI Status
                 .equ	I2S6	= TWS6	; For compatibility
                 .equ	TWS7	= 7	; TWI Status
                 .equ	I2S7	= TWS7	; For compatibility
                 
                 ; TWDR - TWI Data register
                 .equ	I2DR	= TWDR	; For compatibility
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	I2AR	= TWAR	; For compatibility
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EEWEE	= EEMWE	; For compatibility
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 .equ	SM0	= 4	; Sleep Mode Select
                 .equ	SM1	= 5	; Sleep Mode Select
                 .equ	SM2	= 6	; Sleep Mode Select
                 .equ	SE	= 7	; Sleep Enable
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	MCUSR	= MCUCSR	; For compatibility
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; SPMCR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write Section Read Enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PUD	= 2	; Pull-up Disable
                 .equ	ADHSM	= 4	; ADC High Speed Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADCSR	= ADCSRA	; For compatibility
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADFR	= 5	; ADC  Free Running Select
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	BODEN	= 6	; Brown out detector enable
                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	CKOPT	= 4	; Oscillator Options
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	WTDON	= 6	; Enable watchdog
                 .equ	RSTDISBL	= 7	; Disable reset
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 1024
                 .equ	RAMEND	= 0x045f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x01ff
                 .equ	EEPROMEND	= 0x01ff
                 .equ	EEADRBITS	= 9
                 #pragma AVRPART MEMORY PROG_FLASH 8192
                 #pragma AVRPART MEMORY EEPROM 512
                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0xc00
                 .equ	NRWW_STOP_ADDR	= 0xfff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0xbff
                 .equ	PAGESIZE	= 32
                 .equ	FIRSTBOOTSTART	= 0xf80
                 .equ	SECONDBOOTSTART	= 0xf00
                 .equ	THIRDBOOTSTART	= 0xe00
                 .equ	FOURTHBOOTSTART	= 0xc00
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                 .equ	OC2addr	= 0x0003	; Timer/Counter2 Compare Match
                 .equ	OVF2addr	= 0x0004	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0005	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0006	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0007	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x0008	; Timer/Counter1 Overflow
                 .equ	OVF0addr	= 0x0009	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x000a	; Serial Transfer Complete
                 .equ	URXCaddr	= 0x000b	; USART, Rx Complete
                 .equ	UDREaddr	= 0x000c	; USART Data Register Empty
                 .equ	UTXCaddr	= 0x000d	; USART, Tx Complete
                 .equ	ADCCaddr	= 0x000e	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x000f	; EEPROM Ready
                 .equ	ACIaddr	= 0x0010	; Analog Comparator
                 .equ	TWIaddr	= 0x0011	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0012	; Store Program Memory Ready
                 
                 .equ	INT_VECTORS_SIZE	= 19	; size in words
                 
                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                 
                 #endif  /* _M8DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 .equ    NO_POWER         = 256-MIN_DUTY         ; (POWER_OFF)
                 .equ    MAX_POWER        = 256-POWER_RANGE      ; (FULL_POWER)
                 .equ    CONTROL_TOT      = 50                   ; time = NUMBER x 64ms
                 .equ    CURRENT_ERR_MAX  = 3                    ; performs a reset after MAX errors
                 
                 .equ    T1STOP     = 0x00
                 .equ    T1CK8      = 0x02
                 
                 ;**** **** **** **** ****
                 ; Register Definitions
                 .def    i_sreg           = r1   ; status register save in interrupts
                 .def    tcnt0_power_on   = r2   ; timer0 counts nFETs are switched on
                 ;.def   ...              = r3   ; 
                 ;.def   ...              = r4   ; 
                 ;.def   ...              = r5   ;
                 .def    tcnt0_pwroff     = r6   ; timer0 counts nFETs are switched off
                 
                 .def    start_rcpuls_l   = r7
                 .def    start_rcpuls_h   = r8
                 .def    motor_count      = r9
                 ;.def                    = r10
                 .def    control_timeout  = r11
                 .def    current_err      = r12  ; counts consecutive current errors
                 
                 .def    sys_control      = r13
                 .def    t1_timeout       = r14
                 .def    run_control      = r15
                 
                 
                 .def    temp1   = r16                   ; main temporary
                 .def    temp2   = r17                   ; main temporary
                 .def    temp3   = r18                   ; main temporary
                 .def    temp4   = r19                   ; main temporary
                 
                 .def    i_temp1 = r20                   ; interrupt temporary
                 .def    i_temp2 = r21                   ; interrupt temporary
                 .def    i_temp3 = r22                   ; interrupt temporary
                 
                 .def    flags0  = r23   ; state flags
                         .equ    OCT1_PENDING    = 0     ; if set, output compare interrunpt is pending
                         .equ    UB_LOW          = 1     ; set if accu voltage low
                         .equ    I_pFET_HIGH     = 2     ; set if over-current detect
                         .equ    GET_STATE       = 3     ; set if state is to be send
                         .equ    C_FET           = 4     ; if set, C-FET state is to be changed
                         .equ    A_FET           = 5     ; if set, A-FET state is to be changed
                              ; if neither 1 nor 2 is set, B-FET state is to be changed
                         .equ    I_OFF_CYCLE     = 6     ; if set, current off cycle is active
                         .equ    T1OVFL_FLAG     = 7     ; each timer1 overflow sets this flag - used for voltage + current watch
                 
                 .def    flags1  = r24   ; state flags
                         .equ    POWER_OFF       = 0     ; switch fets on disabled
                         .equ    FULL_POWER      = 1     ; 100% on - don't switch off, but do OFF_CYCLE working
                         .equ    CALC_NEXT_OCT1  = 2     ; calculate OCT1 offset, when wait_OCT1_before_switch is called
                         .equ    RC_PULS_UPDATED = 3     ; new rc-puls value available
                         .equ    EVAL_RC_PULS    = 4     ; if set, new rc puls is evaluated, while waiting for OCT1
                         .equ    EVAL_SYS_STATE  = 5     ; if set, overcurrent and undervoltage are checked
                         .equ    EVAL_RPM        = 6     ; if set, next PWM on should look for current
                         .equ    EVAL_PWM        = 7     ; if set, PWM should be updated
                 
                 .def    flags2  = r25
                         .equ    RPM_RANGE1      = 0     ; if set RPM is lower than 1831 RPM
                         .equ    RPM_RANGE2      = 1     ; if set RPM is between 1831 RPM and 3662 RPM
                         .equ    SCAN_TIMEOUT    = 2     ; if set a startup timeout occurred
                         .equ    POFF_CYCLE      = 3     ; if set one commutation cycle is performed without power
                         .equ    COMP_SAVE       = 4     ; if set ACO was high
                         .equ    STARTUP         = 5     ; if set startup-phase is active
                         .equ    RC_INTERVAL_OK  = 6     ; 
                         .equ    NO_SYNC         = 7     ; 
                 
                 ; here the XYZ registers are placed ( r26-r31)
                 
                 ; ZH = new_duty         ; PWM destination
                 
                 
                 ;**** **** **** **** ****
                 ; RAM Definitions
                 .dseg                                   ;EEPROM segment
                 .org SRAM_START
                 
000060           tcnt1_sav_l:    .byte   1       ; actual timer1 value
000061           tcnt1_sav_h:    .byte   1
000062           last_tcnt1_l:   .byte   1       ; last timer1 value
000063           last_tcnt1_h:   .byte   1
000064           timing_l:       .byte   1       ; holds time of 4 commutations 
000065           timing_h:       .byte   1
000066           timing_x:       .byte   1
                 
000067           timing_acc_l:   .byte   1       ; holds the average time of 4 commutations 
000068           timing_acc_h:   .byte   1
000069           timing_acc_x:   .byte   1
                 
00006a           rpm_l:          .byte   1       ; holds the average time of 4 commutations 
00006b           rpm_h:          .byte   1
00006c           rpm_x:          .byte   1
                 
00006d           wt_comp_scan_l: .byte   1       ; time from switch to comparator scan
00006e           wt_comp_scan_h: .byte   1       
00006f           com_timing_l:   .byte   1       ; time from zero-crossing to switch of the appropriate FET
000070           com_timing_h:   .byte   1
000071           wt_OCT1_tot_l:  .byte   1       ; OCT1 waiting time
000072           wt_OCT1_tot_h:  .byte   1
000073           zero_wt_l:      .byte   1
000074           zero_wt_h:      .byte   1
000075           last_com_l:     .byte   1
000076           last_com_h:     .byte   1
                 
000077           stop_rcpuls_l:  .byte   1
000078           stop_rcpuls_h:  .byte   1
000079           new_rcpuls_l:   .byte   1
00007a           new_rcpuls_h:   .byte   1
                 
00007b           duty_offset:    .byte   1
00007c           goodies:        .byte   1
00007d           comp_state:     .byte   1
00007e           uart_command:   .byte   1
                 
00007f           uart_data:      .byte   100             ; only for debug requirements
                 
                 
                 ;**** **** **** **** ****
                 ; ATmega8 interrupts
                 
                 ;.equ   INT0addr=$001   ; External Interrupt0 Vector Address
                 ;.equ   INT1addr=$002   ; External Interrupt1 Vector Address
                 ;.equ   OC2addr =$003   ; Output Compare2 Interrupt Vector Address
                 ;.equ   OVF2addr=$004   ; Overflow2 Interrupt Vector Address
                 ;.equ   ICP1addr=$005   ; Input Capture1 Interrupt Vector Address
                 ;.equ   OC1Aaddr=$006   ; Output Compare1A Interrupt Vector Address
                 ;.equ   OC1Baddr=$007   ; Output Compare1B Interrupt Vector Address
                 ;.equ   OVF1addr=$008   ; Overflow1 Interrupt Vector Address
                 ;.equ   OVF0addr=$009   ; Overflow0 Interrupt Vector Address
                 ;.equ   SPIaddr =$00a   ; SPI Interrupt Vector Address
                 ;.equ   URXCaddr=$00b   ; USART Receive Complete Interrupt Vector Address
                 ;.equ   UDREaddr=$00c   ; USART Data Register Empty Interrupt Vector Address
                 ;.equ   UTXCaddr=$00d   ; USART Transmit Complete Interrupt Vector Address
                 ;.equ   ADCCaddr=$00e   ; ADC Interrupt Vector Address
                 ;.equ   ERDYaddr=$00f   ; EEPROM Interrupt Vector Address
                 ;.equ   ACIaddr =$010   ; Analog Comparator Interrupt Vector Address
                 ;.equ   TWIaddr =$011   ; Irq. vector address for Two-Wire Interface
                 ;.equ   SPMaddr =$012   ; SPM complete Interrupt Vector Address
                 ;.equ   SPMRaddr =$012  ; SPM complete Interrupt Vector Address
                 ;-----bko-----------------------------------------------------------------
                 
                 ;**** **** **** **** ****
                 .cseg
                 .org 0
                 ;**** **** **** **** ****
                 
                 ;-----bko-----------------------------------------------------------------
                 ; reset and interrupt jump table
                 
                 #if !defined(__ext_int0)
                 #endif
                 
                 #if !defined(__ext_int1)
                  #define __ext_int1 reti 
                  .macro __ext_int1_isr
                  .endmacro
                 #endif
                 
000000 c01c                      rjmp    reset
000001 c071                      __ext_int0          ; ext_int0
000002 9518                      __ext_int1          ; ext_int1
000003 9518                      reti                ; t2oc_int
000004 9518                      reti                ; t2ovfl_int
000005 9518                      reti                ; icp1
000006 c0af                      rjmp    t1oca_int
000007 9518                      reti                ; t1ocb_int
000008 c0b1                      rjmp    t1ovfl_int
000009 c0bc                      rjmp    t0ovfl_int
00000a 9518                      reti                ; spi_int
00000b 9518                      reti                ; urxc
00000c 9518                      reti                ; udre
00000d 9518                      reti                ; utxc
00000e 9518                      reti                ; adc_int
00000f 9518                      reti                ; eep_int
000010 9518                      reti                ; aci_int
000011 9518                      reti                ; wire2_int
000012 9518                      reti                ; spmc_int
                 
                 
000013 0a0d      version:        .db     0x0d, 0x0a
000014 6b62
000015 6c50
000016 7375
000017 2068
000018 3033
000019 3134
00001a 7230
00001b 3630                      .db     "bk",Typ,"410r06"
00001c 0a0d                      .db     0x0d, 0x0a
                 
                 ;******************************************************************************
                 ;* MACRO
                 ;*      SetPWMi
                 ;* DECRIPTION
                 ;*      Set PWM immidiate
                 ;* USAGE
                 ;*      SetPWMi(val)
                 ;* STATISTICS
                 ;*      Register usage: none
                 ;******************************************************************************
                 .macro SetPWMi
                                 push    temp1
                                 ldi     temp1, @0
                                 com     temp1
                                 rcall   set_pwm
                 ;                rcall   eval_power_state
                                 pop     temp1
                 .endmacro
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; init after reset
                 
00001d e004      reset:          ldi     temp1, high(RAMEND)     ; stack = RAMEND
00001e bf0e                      out     SPH, temp1
00001f e50f                      ldi     temp1, low(RAMEND)
000020 bf0d                      out     SPL, temp1
                 
                 .if READ_CALIBRATION == 1
                                 ; oscillator calibration byte is written into the uppermost position
                                 ; of the eeprom - by the script 1n1p.e2s an ponyprog
                                 ;CLEARBUFFER
                                 ;LOAD-PROG 1n1p.hex
                                 ;PAUSE "Connect and powerup the circuit, are you ready?"
                                 ;READ-CALIBRATION 0x21FF DATA 3     # <EEProm 8Mhz
                                 ;ERASE-ALL
                                 ;WRITE&VERIFY-ALL
000021 e001                      ldi     temp1,0x01
000022 bb0f                      out     EEARH,temp1
000023 ef0f                      ldi     temp1,$ff
000024 bb0e                      out     EEARL,temp1
000025 9ae0                      sbi     EECR,EERE
000026 b30d                      in      temp1,EEDR
000027 bf01                      out     osccal ,temp1  ;schreiben
                 .endif
                 
                         ; portB
000028 e000                      ldi     temp1, INIT_PB
000029 bb08                      out     PORTB, temp1
00002a e207                      ldi     temp1, DIR_PB
00002b bb07                      out     DDRB, temp1
                 
                         ; portC
00002c e000                      ldi     temp1, INIT_PC
00002d bb05                      out     PORTC, temp1
00002e e000                      ldi     temp1, DIR_PC
00002f bb04                      out     DDRC, temp1
                 
                         ; portD
000030 e000                      ldi     temp1, INIT_PD
000031 bb02                      out     PORTD, temp1
000032 e308                      ldi     temp1, DIR_PD
000033 bb01                      out     DDRD, temp1
                 
                         ; timer0: PWM + beep control = 0x02     ; start timer0 with CK/8 (0.5³s/count)
000034 e002                      ldi     temp1, 0x02
000035 bf03                      out     TCCR0, temp1
                 
                         ; timer1: commutation control = 0x02    ; start timer1 with CK/8 (0.5³s/count)
000036 e002                      ldi     temp1, T1CK8
000037 bd0e                      out     TCCR1B, temp1
                 
                         ; reset state flags
000038 2777                      clr     flags0
000039 2788                      clr     flags1
00003a 2799                      clr     flags2
                 
                         ; clear RAM
00003b 27bb                      clr     XH
00003c e6a0                      ldi     XL, low (SRAM_START)
00003d 2700                      clr     temp1
00003e 930d      clear_ram:      st      X+, temp1
00003f 38a0                      cpi     XL, uart_data+1
000040 f3e8                      brlo    clear_ram
                 
                         ; power off
000041 d26f                      rcall   switch_power_off
                 
                         ; reset rc puls timeout
000042 e302                      ldi     temp1, CONTROL_TOT*CLK_SCALE
000043 2eb0                      mov     control_timeout, temp1
                                 
000044 d0d9                      rcall   wait260ms       ; wait a while
000045 d0d8                      rcall   wait260ms
                 
000046 d0ab                      rcall   beep_f1
000047 d0ca                      rcall   wait30ms
000048 d0ac                      rcall   beep_f2
000049 d0c8                      rcall   wait30ms
00004a d0ad                      rcall   beep_f3
00004b d0c6                      rcall   wait30ms
                 
                 control_start:  ; init variables
00004c 930f
00004d e005
00004e 9500
00004f d10a
000050 910f                      SetPWMi(MIN_DUTY-1)
000051 e000                      ldi     temp1, 0                ; reset error counters
000052 2ec0                      mov     current_err,temp1
000053 2ed0                      mov     sys_control, temp1
                 
                         ; init registers and interrupts
000054 e105                      ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
000055 bf08                      out     TIFR, temp1             ; clear TOIE1,OCIE1A & TOIE0
000056 bf09                      out     TIMSK, temp1            ; enable TOIE1,OCIE1A & TOIE0 interrupts
                 
000057 9478                      sei                             ; enable all interrupts
                 
000058 e003
000059 bf05
00005a e430
00005b bf3b                      init_input
00005c e02a      i_rc_puls1:     ldi     temp3, 10               ; wait for this count of receiving power off
00005d ff83      i_rc_puls2:     sbrs    flags1, RC_PULS_UPDATED
00005e cffe                      rjmp    i_rc_puls2
00005f 9100 0079                 lds     temp1, new_rcpuls_l
000061 9110 007a                 lds     temp2, new_rcpuls_h
000063 7f87                      cbr     flags1, (1<<RC_PULS_UPDATED) ; rc impuls value is read out
000064 540c                      subi    temp1, low  (MIN_RC_PULS*CLK_SCALE)     ; power off received ?
000065 4014                      sbci    temp2, high (MIN_RC_PULS*CLK_SCALE)
000066 f7a8                      brcc    i_rc_puls1              ; no - reset counter
000067 952a                      dec     temp3                   ; yes - decrement counter
000068 f7a1                      brne    i_rc_puls2              ; repeat until zero
000069 94f8                      cli                             ; disable all interrupts
00006a d090                      rcall   beep_f4                 ; signal: rcpuls ready
00006b d08f                      rcall   beep_f4
00006c d08e                      rcall   beep_f4
00006d 9478                      sei                             ; enable all interrupts
                 
00006e e10e                      ldi     temp1, 30
00006f 9300 007b                 sts     duty_offset, temp1
                 
000071 d164                      rcall   set_all_timings
                 
000072 c286                      rjmp    init_startup
                 ;-----bko-----------------------------------------------------------------
000073 b61f
000074 b745
000075 ff40
000076 c01d
000077 9b82
000078 c03b
000079 e042
00007a bf45
00007b b54c
00007c b55d
00007d 2e74
00007e 2e85
00007f 7b9f
000080 9160 0077
000082 1b46
000083 9160 0078
000085 0b56
000086 3a48
000087 e661
000088 0756
000089 f430
00008a 3948
00008b e36a
00008c 0756
00008d f010
00008e 6490
00008f c024
000090 20bb
000091 f111
000092 94ba
000093 c020
000094 9982
000095 c01e
000096 e043
000097 bf45
000098 fd83
000099 c01a
00009a b54c
00009b b55d
00009c 9340 0077
00009e 9350 0078
0000a0 ff96
0000a1 c012
0000a2 7b9f
0000a3 1947
0000a4 0958
0000a5 9340 0079
0000a7 9350 007a
0000a9 3948
0000aa e068
0000ab 0756
0000ac f718
0000ad 3240
0000ae e063
0000af 0756
0000b0 f2f8
0000b1 6088
0000b2 e342
0000b3 2eb4
0000b4 be1f
0000b5 9518      ext_int0_isr:   __ext_int0_isr
                 ext_int1_isr:   __ext_int1_isr
                 ;-----bko-----------------------------------------------------------------
                 ; output compare timer1 interrupt
0000b6 b61f      t1oca_int:      in      i_sreg, SREG
0000b7 7f7e                      cbr     flags0, (1<<OCT1_PENDING) ; signal OCT1 passed
0000b8 be1f                      out     SREG, i_sreg
0000b9 9518                      reti
                 ;-----bko-----------------------------------------------------------------
                 ; overflow timer1 / happens all 32768³s / 65536³s
0000ba b61f      t1ovfl_int:     in      i_sreg, SREG
0000bb 6870                      sbr     flags0, (1<<T1OVFL_FLAG)
                 
0000bc 20ee                      tst     t1_timeout
0000bd f009                      breq    t1ovfl_10
0000be 94ea                      dec     t1_timeout
                 
0000bf 20bb      t1ovfl_10:      tst     control_timeout
0000c0 f411                      brne    t1ovfl_20
0000c1 27ff                      clr     ZH
0000c2 c001                      rjmp    t1ovfl_99
0000c3 94ba      t1ovfl_20:      dec     control_timeout
                 
0000c4 be1f      t1ovfl_99:      out     SREG, i_sreg
0000c5 9518                      reti
                 ;-----bko-----------------------------------------------------------------
                 ; timer0 overflow interrupt
0000c6 b61f      t0ovfl_int:     in      i_sreg, SREG
                 ;                DbgLEDOff
0000c7 fd76                      sbrc    flags0, I_OFF_CYCLE
0000c8 c014                      rjmp    t0_on_cycle
                 
                 t0_off_cycle:   
0000c9 be62                      out     TCNT0, tcnt0_pwroff     ; reload t0
                                 ; mirror inverted ACO to bit-var
0000ca 6190                      sbr     flags2, (1<<COMP_SAVE)
0000cb 9945                      sbic    ACSR, ACO               
0000cc 7e9f                      cbr     flags2, (1<<COMP_SAVE)
                                 ; PWM state = off cycle
0000cd 6470                      sbr     flags0, (1<<I_OFF_CYCLE)
                                 ; We can just turn them all off as we only have one nFET on at a
                                 ; time, and interrupts are disabled during beeps.
0000ce 98c0                      CnFET_off
0000cf 98c2                      AnFET_off
0000d0 98c1                      BnFET_off
                 
                 
0000d1 2d46                      mov     i_temp1, tcnt0_pwroff
0000d2 3040                      cpi     i_temp1, 0
0000d3 f021                      breq    t0_on_cycle_t1
0000d4 3041                      cpi     i_temp1, 1
0000d5 f039                      breq    t0_on_cycle_t0
                 
0000d6 be1f                      out     SREG, i_sreg
0000d7 9518                      reti
                 
                 t0_on_cycle_t1:
0000d8 0000                      nop
0000d9 0000                      nop                
0000da 0000                      nop
0000db 0000                      nop                
0000dc 0000                      nop
                 ;                nop                
                 ;                nop
                 ;                nop                
                                 
                                 
                 t0_on_cycle_t0:
                 ;                nop
                 ;                nop      
                 ;                nop
                 ;                nop      
                 ;                DbgLEDOn          
                 
                 
                 t0_on_cycle:
0000dd fd80                      sbrc    flags1, POWER_OFF
0000de c009                      rjmp    t0_on_cycle_tcnt
                                 ; switch appropriate nFET on as soon as possible
0000df ff74                      sbrs    flags0, C_FET           ; is Cn choppered ?
0000e0 c002                      rjmp    test_AnFET_on                   ; .. no - test An
0000e1 9ac0                      CnFET_on                        ; Cn on
0000e2 c005                      rjmp    t0_on_cycle_tcnt
0000e3 ff75      test_AnFET_on:  sbrs    flags0, A_FET           ; is An choppered ?
0000e4 c002                      rjmp    sw_BnFET_on                     ; .. no - Bn has to be choppered
0000e5 9ac2                      AnFET_on                        ; An on
0000e6 c001                      rjmp    t0_on_cycle_tcnt
                 sw_BnFET_on:    
0000e7 9ac1                      BnFET_on                        ; Bn on
                 t0_on_cycle_tcnt:
0000e8 7b7f                      cbr     flags0, (1<<I_OFF_CYCLE); PWM state = on cycle
0000e9 2d42                      mov     i_temp1, tcnt0_power_on
0000ea 7f8d                      cbr     flags1, (1<<FULL_POWER)
0000eb 3348                      cpi     i_temp1, MAX_POWER
0000ec f410                      brsh    t0_on_cycle_not_full_power
0000ed 6082                      sbr     flags1, (1<<FULL_POWER)
0000ee 6470                      sbr     flags0, (1<<I_OFF_CYCLE)
                 t0_on_cycle_not_full_power:
0000ef be22                      out     TCNT0, tcnt0_power_on   ; reload t0
0000f0 be1f                      out     SREG, i_sreg
0000f1 9518                      reti                   
                 ;-----bko-----------------------------------------------------------------
                 ; beeper: timer0 is set to 1³s/count
0000f2 ec38      beep_f1:        ldi     temp4, 200
0000f3 e510                      ldi     temp2, 80
0000f4 c009                      rjmp    beep
                 
0000f5 eb34      beep_f2:        ldi     temp4, 180
0000f6 e614                      ldi     temp2, 100
0000f7 c006                      rjmp    beep
                 
0000f8 ea30      beep_f3:        ldi     temp4, 160
0000f9 e718                      ldi     temp2, 120
0000fa c003                      rjmp    beep
                 
0000fb e634      beep_f4:        ldi     temp4, 100
0000fc ec18                      ldi     temp2, 200
0000fd c000                      rjmp    beep
                 
0000fe 2700      beep:           clr     temp1
0000ff bf02                      out     TCNT0, temp1
000100 9a94                      BpFET_on                ; BpFET on
000101 9ac2                      AnFET_on                ; CnFET on
000102 b702      beep_BpCn10:    in      temp1, TCNT0
000103 3200                      cpi     temp1, 32*CLK_SCALE             ; 32³s on
000104 f7e9                      brne    beep_BpCn10
000105 9894                      BpFET_off               ; BpFET off
000106 98c2                      AnFET_off               ; CnFET off
000107 e028                      ldi     temp3, 8*CLK_SCALE              ; 2040³s off
000108 2700      beep_BpCn12:    clr     temp1
000109 bf02                      out     TCNT0, temp1
00010a b702      beep_BpCn13:    in      temp1, TCNT0
00010b 1703                      cp      temp1, temp4
00010c f7e9                      brne    beep_BpCn13
00010d 952a                      dec     temp3
00010e f7c9                      brne    beep_BpCn12
00010f 951a                      dec     temp2
000110 f769                      brne    beep
000111 9508                      ret
                 
000112 e01f      wait30ms:       ldi     temp2, 15*CLK_SCALE
000113 e028      beep_BpCn20:    ldi     temp3, 8*CLK_SCALE
000114 2700      beep_BpCn21:    clr     temp1
000115 bf02                      out     TCNT0, temp1
000116 b702      beep_BpCn22:    in      temp1, TCNT0
000117 3f0f                      cpi     temp1, 255
000118 f7e9                      brne    beep_BpCn22
000119 952a                      dec     temp3
00011a f7c9                      brne    beep_BpCn21
00011b 951a                      dec     temp2
00011c f7b1                      brne    beep_BpCn20
00011d 9508                      ret
                 
                         ; 256 periods = 261ms silence
00011e e71f      wait260ms:      ldi     temp2, 127*CLK_SCALE    ; = 256
00011f e028      beep2_BpCn20:   ldi     temp3, 8*CLK_SCALE
000120 2700      beep2_BpCn21:   clr     temp1
000121 bf02                      out     TCNT0, temp1
000122 b702      beep2_BpCn22:   in      temp1, TCNT0
000123 3f0f                      cpi     temp1, 255
000124 f7e9                      brne    beep2_BpCn22
000125 952a                      dec     temp3
000126 f7c9                      brne    beep2_BpCn21
000127 951a                      dec     temp2
000128 f7b1                      brne    beep2_BpCn20
000129 9508                      ret                
                 ;-----bko-----------------------------------------------------------------
                 tcnt1_to_temp:  
00012a e030
00012b bf3b                      disable_input
00012c e030                      ldi     temp4, T1STOP           ; stop timer1
00012d bd3e                      out     TCCR1B, temp4
00012e e032                      ldi     temp4, T1CK8            ; preload temp with restart timer1
00012f b50c                      in      temp1, TCNT1L           ;  - the preload cycle is needed to complete stop operation
000130 b51d                      in      temp2, TCNT1H
000131 bd3e                      out     TCCR1B, temp4
000132 9508                      ret                             ; !!! ext0int stays disabled - must be enabled again by caller
                         ; there seems to be only one TEMP register in the AVR
                         ; if the ext0int interrupt falls between readad LOW value while HIGH value is captured in TEMP and
                         ; read HIGH value, TEMP register is changed in ext0int routine
                 ;-----bko-----------------------------------------------------------------
                 evaluate_rc_puls:
000133 7e8f
000134 ff83
000135 c013
000136 9100 0079
000138 9110 007a
00013a 7f87
00013b 540c
00013c 4014
00013d f410
00013e 2700
00013f 2711
000140 9516
000141 9507
000142 9516
000143 9507
000144 2f20
000145 5c08
000146 f008
000147 ec28
000148 2ff2
000149 9508                      EvaluatePWC
                 ;-----bko-----------------------------------------------------------------
                 evaluate_sys_state:
00014a 7d8f                      cbr     flags1, (1<<EVAL_SYS_STATE)
00014b ff77                      sbrs    flags0, T1OVFL_FLAG
00014c c00a                      rjmp    eval_sys_s99
                 
                         ; do it not more often as every 32³s
00014d 777f                      cbr     flags0, (1<<T1OVFL_FLAG)
                 
                         ; control current
00014e c005      eval_sys_i:     rjmp    eval_sys_i_ok
                 
00014f 2d4c                      mov     i_temp1, current_err
000150 3043                      cpi     i_temp1, CURRENT_ERR_MAX
000151 f430                      brcc    panic_exit
000152 94c3                      inc     current_err
000153 c003                      rjmp    eval_sys_ub
                 
000154 20cc      eval_sys_i_ok:  tst     current_err
000155 f009                      breq    eval_sys_ub
000156 94ca                      dec     current_err
                 
                 eval_sys_ub:    
000157 9508      eval_sys_s99:   ret
                 
                 panic_exit:     ; !!!!!! OVERCURRENT !!!!!!!!
000158 94f8                      cli
000159 cec3                      rjmp    reset
                 ;-----bko-----------------------------------------------------------------
                 ;******************************************************************************
                 ;* FUNCTION
                 ;*      set_pwm
                 ;* DECRIPTION
                 ;*      Calculates tcnt0 values for ON and off cycles.
                 ;*      Performs PWM correction.
                 ;* USAGE
                 ;*      temp1
                 ;* STATISTICS
                 ;*      Register usage: temp1
                 ;******************************************************************************
                 set_pwm:
                 ;                inc     temp1                   ; Make it shorter by 3 cycles
                 ;                inc     temp1
                 ;                inc     temp1
00015a 2e20                      mov     tcnt0_power_on, temp1
00015b 5308                      subi    temp1, -POWER_RANGE     
00015c 9500                      com     temp1   
00015d 9503                      inc     temp1            
00015e 9503                      inc     temp1            
00015f 2e60                      mov     tcnt0_pwroff, temp1
000160 9508                      ret
                 
                 ;******************************************************************************
                 ;* FUNCTION
                 ;*      eval_power_state
                 ;* DECRIPTION
                 ;*      Evaluates current state
                 ;* USAGE
                 ;*      temp1
                 ;* STATISTICS
                 ;*      Register usage: none
                 ;******************************************************************************
                 eval_power_state:
000161 3309                      cpi     temp1, MAX_POWER+1
000162 f410                      brsh    not_full_power
                                 ; FULL POWER
                 ;               sbr     flags1, (1<<FULL_POWER) ; tcnt0_power_on = MAX_POWER means FULL_POWER
000163 7f8e                      cbr     flags1, (1<<POWER_OFF)
                                 ;DbgLEDOn
000164 c005                      rjmp    eval_power_state_exit
000165 3f0a      not_full_power: cpi     temp1, NO_POWER
000166 f010                      brlo    neither_full_nor_off
                         ; POWER OFF
                 ;               cbr     flags1, (1<<FULL_POWER) ; tcnt0_power_on = NO_POWER means power off
000167 6081                      sbr     flags1, (1<<POWER_OFF)
                                 ;DbgLEDOff
000168 c001                      rjmp    eval_power_state_exit
                 neither_full_nor_off:
                 ;               cbr     flags1, (1<<FULL_POWER) ; tcnt0_power_on = MAX_POWER means FULL_POWER
000169 7f8e                      cbr     flags1, (1<<POWER_OFF)
                                 ;DbgLEDOff
                 eval_power_state_exit:    
00016a fd93                      sbrc    flags2, POFF_CYCLE
00016b 6081                      sbr     flags1, (1<<POWER_OFF)
00016c 9508                      ret
                 ;******************************************************************************
                 ;* FUNCTION
                 ;*      set_new_duty
                 ;* DECRIPTION
                 ;*     1) Evaluates duty cycle
                 ;*     2) Limits power to sys_control
                 ;*     3) Limits starup power
                 ;*     4) Limits RPM ranges power
                 ;*     5) Increments sys_control up to POWER_RANGE
                 ;* USAGE
                 ;*      ZH (0-POWER_RANGE)
                 ;* STATISTICS
                 ;*      Register usage: temp1, temp2, temp3 
                 ;******************************************************************************
                 set_new_duty:   
00016d 2f0f                      mov     temp1, ZH
00016e 2d1d                      mov     temp2, sys_control      ; Limit PWM to sys_control
00016f 1701                      cp      temp1, temp2
000170 f020                      brcs    set_new_duty10
000171 2f01                      mov     temp1, temp2
000172 3c18                      cpi     temp2, POWER_RANGE
000173 f009                      breq    set_new_duty10
000174 94d3                      inc     sys_control             ; Build up sys_control to POWER_RANGE
000175 9110 0066 set_new_duty10: lds     temp2, timing_x
000177 2311                      tst     temp2
000178 f421                      brne    set_new_duty12
000179 9110 0065                 lds     temp2, timing_h         ; get actual RPM reference high
00017b 3410                      cpi     temp2, PWR_RANGE1*CLK_SCALE ; lower range1 ?
00017c f038                      brcs    set_new_duty20          ; on carry - test next range ; lower as range1
00017d 6091      set_new_duty12: sbr     flags2, (1<<RPM_RANGE1)
00017e 6092                      sbr     flags2, (1<<RPM_RANGE2)
00017f e312                      ldi     temp2, PWR_MAX_RPM1     ; higher than range1 power max ?
000180 1701                      cp      temp1, temp2
000181 f060                      brcs    set_new_duty40          ; on carry - not higher, no restriction
000182 2f01                      mov     temp1, temp2            ; low (range1) RPM - set PWR_MAX_RPM1
000183 c00a                      rjmp    set_new_duty40          ; higher as range1
000184 3210      set_new_duty20: cpi     temp2, PWR_RANGE2*CLK_SCALE; lower range2 ?
000185 f038                      brcs    set_new_duty30          ; on carry - not lower, no restriction
000186 7f9e      set_new_duty22: cbr     flags2, (1<<RPM_RANGE1)
000187 6092                      sbr     flags2, (1<<RPM_RANGE2)
000188 e614                      ldi     temp2, PWR_MAX_RPM2     ; higher than range2 power max ?
000189 1701                      cp      temp1, temp2
00018a f018                      brcs    set_new_duty40          ; on carry - not higher, no restriction
00018b 2f01                      mov     temp1, temp2            ; low (range2) RPM - set PWR_MAX_RPM2
00018c c001                      rjmp    set_new_duty40          ; higher as range2
00018d 7f9c      set_new_duty30: cbr     flags2, (1<<RPM_RANGE1)+(1<<RPM_RANGE2)  ; range limits are evaluated - look for STARTUP conditions
00018e ff95      set_new_duty40: sbrs    flags2, STARTUP
00018f c009                      rjmp    set_new_duty50
000190 e02a                      ldi     temp3, PWR_STARTUP      ; at least PWR_STARTUP ?
000191 1702                      cp      temp1, temp3
000192 f410                      brcc    set_new_duty42          ; on no carry - higher than PWR_STARTUP, test PWR_MAX_STARTUP
000193 e00a                      ldi     temp1, PWR_STARTUP      ; lower - set to PWR_STARTUP
000194 c004                      rjmp    set_new_duty50
000195 e128      set_new_duty42: ldi     temp3, PWR_MAX_STARTUP  ; limit power in startup phase
000196 1702                      cp      temp1, temp3
000197 f008                      brcs    set_new_duty50          ; on carry - not higher, test range 2
000198 2f02                      mov     temp1, temp3            ; set PWR_MAX_STARTUP limit
000199 9500      set_new_duty50: com     temp1                   ; down-count to up-count (T0)
00019a 94f8                      cli 
00019b dfc5                      rcall   eval_power_state        ; evaluate power state
00019c dfbd                      rcall   set_pwm                 ; set new PWM
00019d 9478                      sei
00019e 9508                      ret
                 ;-----bko-----------------------------------------------------------------
00019f 7b8f      evaluate_rpm:   cbr     flags1, (1<<EVAL_RPM)
0001a0 9120 006c                 lds     temp3, rpm_x
0001a2 9110 006b                 lds     temp2, rpm_h
                 
0001a4 9100 006a                 lds     temp1, rpm_l    ; subtract 1/256
0001a6 1b01                      sub     temp1, temp2
0001a7 9300 006a                 sts     rpm_l, temp1
0001a9 9100 006b                 lds     temp1, rpm_h
0001ab 0b02                      sbc     temp1, temp3
0001ac 9300 006b                 sts     rpm_h, temp1
0001ae 9100 006c                 lds     temp1, rpm_x
0001b0 4000                      sbci    temp1, 0
0001b1 9300 006c                 sts     rpm_x, temp1
                 
0001b3 9120 0069                 lds     temp3, timing_acc_x
0001b5 9110 0068                 lds     temp2, timing_acc_h
0001b7 9100 0067                 lds     temp1, timing_acc_l
0001b9 9526                      lsr     temp3           ; make one complete commutation cycle
0001ba 9517                      ror     temp2
0001bb 9507                      ror     temp1
0001bc 9526                      lsr     temp3
0001bd 9517                      ror     temp2
0001be 9507                      ror     temp1
                         ; temp3 is zero now - for sure !!
0001bf 9320 0069                 sts     timing_acc_x, temp3
0001c1 9320 0068                 sts     timing_acc_h, temp3
0001c3 9320 0067                 sts     timing_acc_l, temp3
                         ; and add the result as 1/256
0001c5 9120 006a                 lds     temp3, rpm_l
0001c7 0f20                      add     temp3, temp1
0001c8 9320 006a                 sts     rpm_l, temp3
0001ca 9120 006b                 lds     temp3, rpm_h
0001cc 1f21                      adc     temp3, temp2
0001cd 9320 006b                 sts     rpm_h, temp3
0001cf e000                      ldi     temp1, 0
0001d0 9120 006c                 lds     temp3, rpm_x
0001d2 1f20                      adc     temp3, temp1
0001d3 9320 006c                 sts     rpm_x, temp3
                 
0001d5 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 set_all_timings:
0001d6 e8c0                      ldi     YL, low  (timeoutSTART)
0001d7 ebdb                      ldi     YH, high (timeoutSTART)
0001d8 93c0 0071                 sts     wt_OCT1_tot_l, YL
0001da 93d0 0072                 sts     wt_OCT1_tot_h, YH
0001dc ef2f                      ldi     temp3, 0xff
0001dd e13f                      ldi     temp4, 0x1f
0001de 9320 006d                 sts     wt_comp_scan_l, temp3
0001e0 9330 006e                 sts     wt_comp_scan_h, temp4
0001e2 9320 006f                 sts     com_timing_l, temp3
0001e4 9330 0070                 sts     com_timing_h, temp4
                 set_timing_v:   
                 .if CLK_SCALE==1
0001e6 e0e1                      ldi     ZL, 0x01
                 .endif                
                 .if CLK_SCALE==2
                 .endif                
0001e7 93e0 0066                 sts     timing_x, ZL
0001e9 ef3f                      ldi     temp4, 0xff
0001ea 9330 0065                 sts     timing_h, temp4
0001ec ef2f                      ldi     temp3, 0xff
0001ed 9320 0064                 sts     timing_l, temp3
                 
0001ef 9508                      ret
                 ;-----bko-----------------------------------------------------------------
0001f0 df39      update_timing:  rcall   tcnt1_to_temp
0001f1 9300 0060                 sts     tcnt1_sav_l, temp1
0001f3 9310 0061                 sts     tcnt1_sav_h, temp2
0001f5 0f0c                      add     temp1, YL
0001f6 1f1d                      adc     temp2, YH
0001f7 e035                      ldi     temp4, (1<<TOIE1)+(1<<TOIE0)
0001f8 bf39                      out     TIMSK, temp4
0001f9 bd1b                      out     OCR1AH, temp2
0001fa bd0a                      out     OCR1AL, temp1
0001fb 6071                      sbr     flags0, (1<<OCT1_PENDING)
0001fc e135                      ldi     temp4, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; enable interrupt again
0001fd bf39                      out     TIMSK, temp4
0001fe e430
0001ff bf3b                      enable_input
                 
                         ; calculate next waiting times - timing(-l-h-x) holds the time of 4 commutations
000200 9100 0064                 lds     temp1, timing_l
000202 9110 0065                 lds     temp2, timing_h
000204 91e0 0066                 lds     ZL, timing_x
                 
000206 9300 0073                 sts     zero_wt_l, temp1        ; save for zero crossing timeout
000208 9310 0074                 sts     zero_wt_h, temp2
00020a 23ee                      tst     ZL
00020b f029                      breq    update_t00
00020c ef3f                      ldi     temp4, 0xff
00020d 9330 0073                 sts     zero_wt_l, temp4        ; save for zero crossing timeout
00020f 9330 0074                 sts     zero_wt_h, temp4
                 update_t00:
000211 95e6                      lsr     ZL                      ; build a quarter
000212 9517                      ror     temp2
000213 9507                      ror     temp1
                 
000214 95e6                      lsr     ZL
000215 9517                      ror     temp2
000216 9507                      ror     temp1
000217 9120 0064                 lds     temp3, timing_l         ; .. and subtract from timing
000219 9130 0065                 lds     temp4, timing_h
00021b 91e0 0066                 lds     ZL, timing_x
00021d 1b20                      sub     temp3, temp1
00021e 0b31                      sbc     temp4, temp2
00021f 40e0                      sbci    ZL, 0
                 
000220 9100 0060                 lds     temp1, tcnt1_sav_l      ; calculate this commutation time
000222 9110 0061                 lds     temp2, tcnt1_sav_h
000224 91c0 0062                 lds     YL, last_tcnt1_l
000226 91d0 0063                 lds     YH, last_tcnt1_h
000228 9300 0062                 sts     last_tcnt1_l, temp1
00022a 9310 0063                 sts     last_tcnt1_h, temp2
00022c 1b0c                      sub     temp1, YL
00022d 0b1d                      sbc     temp2, YH
00022e 9300 0075                 sts     last_com_l, temp1
000230 9310 0076                 sts     last_com_h, temp2
                 
000232 0f20                      add     temp3, temp1            ; .. and add to timing
000233 1f31                      adc     temp4, temp2
000234 e010                      ldi     temp2, 0
000235 1fe1                      adc     ZL, temp2
                 
                         ; limit RPM to 120.000
000236 23ee                      tst     ZL
000237 f441                      brne    update_t90
000238 2333                      tst     temp4
000239 f021                      breq    update_t10
00023a 3031                      cpi     temp4, 0x01*CLK_SCALE
00023b f421                      brne    update_t90
00023c 342c                      cpi     temp3, 0x4c*CLK_SCALE   ; 120.000 RPM
00023d f410                      brcc    update_t90
                         ; set RPM to 120.000
                 
                 update_t10:
00023e e604                      ldi     temp1, PWR_MAX_RPM2
00023f 2ed0                      mov     sys_control, temp1
                 
                 ;update_t10:    ldi     temp4, 0x01*CLK_SCALE
                 ;               ldi     temp3, 0x4c*CLK_SCALE
                 ;               tst     run_control 
                 ;               brne    update_t90              ; just active
                 ;               ldi     temp1, 0xff             ; not active - reactivate
                 ;               mov     run_control, temp1
                 
000240 9320 0064 update_t90:     sts     timing_l, temp3
000242 9330 0065                 sts     timing_h, temp4
000244 93e0 0066                 sts     timing_x, ZL
                 .if CLK_SCALE==1
000246 30e2                      cpi     ZL, 0x02                ; limit range to 0x1ffff
                 .endif                
                 .if CLK_SCALE==2                                
                 .endif                
000247 f008                      brcs    update_t99
000248 df9d                      rcall   set_timing_v
                 
000249 9100 0067 update_t99:     lds     temp1, timing_acc_l
00024b 0f02                      add     temp1, temp3
00024c 9300 0067                 sts     timing_acc_l, temp1
00024e 9100 0068                 lds     temp1, timing_acc_h
000250 1f03                      adc     temp1, temp4
000251 9300 0068                 sts     timing_acc_h, temp1
000253 9100 0069                 lds     temp1, timing_acc_x
000255 1f0e                      adc     temp1, ZL
000256 9300 0069                 sts     timing_acc_x, temp1
                 
000258 95e6                      lsr     ZL                      ; a 16th is the next wait before scan
000259 9537                      ror     temp4
00025a 9527                      ror     temp3
00025b 95e6                      lsr     ZL
00025c 9537                      ror     temp4
00025d 9527                      ror     temp3
00025e 95e6                      lsr     ZL
00025f 9537                      ror     temp4
000260 9527                      ror     temp3
000261 95e6                      lsr     ZL
000262 9537                      ror     temp4
000263 9527                      ror     temp3
000264 9320 006d                 sts     wt_comp_scan_l, temp3
000266 9330 006e                 sts     wt_comp_scan_h, temp4
                 
                         ; use the same value for commutation timing (15-)
000268 9320 006f                 sts     com_timing_l, temp3
00026a 9330 0070                 sts     com_timing_h, temp4
                 
00026c 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 calc_next_timing:
00026d 91c0 006d                 lds     YL, wt_comp_scan_l      ; holds wait-before-scan value
00026f 91d0 006e                 lds     YH, wt_comp_scan_h
000271 df7e                      rcall   update_timing
                 
000272 9508                      ret
                 
000273 fd70      wait_OCT1_tot:  sbrc    flags0, OCT1_PENDING
000274 cffe                      rjmp    wait_OCT1_tot
                 
                 set_OCT1_tot:   AcInit
                 
000275 91d0 0074                 lds     YH, zero_wt_h
000277 91c0 0073                 lds     YL, zero_wt_l
000279 deb0                      rcall   tcnt1_to_temp
00027a 0f0c                      add     temp1, YL
00027b 1f1d                      adc     temp2, YH
00027c e035                      ldi     temp4, (1<<TOIE1)+(1<<TOIE0)
00027d bf39                      out     TIMSK, temp4
00027e bd1b                      out     OCR1AH, temp2
00027f bd0a                      out     OCR1AL, temp1
000280 6071                      sbr     flags0, (1<<OCT1_PENDING)
000281 e135                      ldi     temp4, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
000282 bf39                      out     TIMSK, temp4
000283 e430
000284 bf3b                      enable_input
000285 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 wait_OCT1_before_switch:
000286 dea3                      rcall   tcnt1_to_temp
000287 91c0 006f                 lds     YL, com_timing_l
000289 91d0 0070                 lds     YH, com_timing_h
00028b 0f0c                      add     temp1, YL
00028c 1f1d                      adc     temp2, YH
00028d e025                      ldi     temp3, (1<<TOIE1)+(1<<TOIE0)
00028e bf29                      out     TIMSK, temp3
00028f bd1b                      out     OCR1AH, temp2
000290 bd0a                      out     OCR1AL, temp1
000291 6071                      sbr     flags0, (1<<OCT1_PENDING)
000292 e125                      ldi     temp3, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
000293 bf29                      out     TIMSK, temp3
000294 e430
000295 bf3b                      enable_input
                 
                         ; don't waste time while waiting - do some controls, if indicated
000296 fd84                      sbrc    flags1, EVAL_RC_PULS
000297 de9b                      rcall   evaluate_rc_puls
000298 fd85                      sbrc    flags1, EVAL_SYS_STATE
000299 deb0                      rcall   evaluate_sys_state
                 
00029a fd87                      sbrc    flags1, EVAL_PWM
00029b ded1                      rcall   set_new_duty
                 
00029c fd86                      sbrc    flags1, EVAL_RPM
00029d df01                      rcall   evaluate_rpm
                 
00029e fd70      OCT1_wait:      sbrc    flags0, OCT1_PENDING
00029f cffe                      rjmp    OCT1_wait
0002a0 9508                      ret
                 ;-----bko-----------------------------------------------------------------
0002a1 91c0 0071 start_timeout:  lds     YL, wt_OCT1_tot_l
0002a3 91d0 0072                 lds     YH, wt_OCT1_tot_h
0002a5 df4a                      rcall   update_timing
                 
0002a6 b50c                      in      temp1, TCNT1L
0002a7 700f                      andi    temp1, 0x0f
0002a8 1bd0                      sub     YH, temp1
0002a9 38dc                      cpi     YH, high (timeoutMIN)
0002aa f408                      brcc    set_tot2
0002ab ebdb                      ldi     YH, high (timeoutSTART)         
                 set_tot2:
0002ac 93d0 0072                 sts     wt_OCT1_tot_h, YH
                 
0002ae d018                      rcall   sync_with_poweron       ; wait at least 100+ microseconds
0002af d017                      rcall   sync_with_poweron       ; for demagnetisation - one sync may be added
                 
0002b0 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 switch_power_off:
0002b1 e0f5                      ldi     ZH, MIN_DUTY-1          ; ZH is new_duty
0002b2 930f
0002b3 e005
0002b4 9500
0002b5 dea4
0002b6 910f                      SetPWMi(MIN_DUTY-1)
                 
0002b7 e000                      ldi     temp1, 0                ; reset limiter
0002b8 2ed0                      mov     sys_control, temp1
                 
0002b9 e000                      ldi     temp1, INIT_PB          ; all off
0002ba bb08                      out     PORTB, temp1
0002bb e000                      ldi     temp1, INIT_PC          ; all off
0002bc bb05                      out     PORTC, temp1
0002bd e000                      ldi     temp1, INIT_PD          ; all off
0002be bb02                      out     PORTD, temp1
                 
0002bf 6081                      sbr     flags1, (1<<POWER_OFF)  ; disable power on
0002c0 7f97                      cbr     flags2, (1<<POFF_CYCLE)
0002c1 6290                      sbr     flags2, (1<<STARTUP)
0002c2 9508                      ret                             ; motor is off
                 ;-----bko-----------------------------------------------------------------
0002c3 e004      wait_if_spike:  ldi     temp1, 4*CLK_SCALE
0002c4 950a      wait_if_spike2: dec     temp1
0002c5 f7f1                      brne    wait_if_spike2
0002c6 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 sync_with_poweron:
0002c7 fd76                      sbrc    flags0, I_OFF_CYCLE     ; first wait for power on
0002c8 cffe                      rjmp    sync_with_poweron
                 wait_for_poweroff:
0002c9 ff76                      sbrs    flags0, I_OFF_CYCLE     ; now wait for power off
0002ca cffe                      rjmp    wait_for_poweroff
0002cb 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 motor_brake:
                 .if MOT_BRAKE == 1
                 .endif  ; MOT_BRAKE == 1
0002cc 9508                      ret
                 
                 
                 wait64ms:
0002cd e001                      ldi     temp1, 1*CLK_SCALE
0002ce 2ee0                      mov     t1_timeout, temp1
                 wait120ms_wait_for_t1:    
0002cf 20ee                      tst     t1_timeout
0002d0 f7f1                      brne    wait120ms_wait_for_t1
0002d1 9508                      ret
                 
0002d2 e000      pre_align:      ldi     temp1, INIT_PB  ; all off
0002d3 bb08                      out     PORTB, temp1
0002d4 e000                      ldi     temp1, INIT_PD  ; all off
0002d5 bb02                      out     PORTD, temp1
0002d6 e000                      ldi     temp1, INIT_PC  ; all off
0002d7 bb05                      out     PORTC, temp1
0002d8 e104                      ldi     temp1, 20*CLK_SCALE
0002d9 950a      pp_FETs_off_wt: dec     temp1
0002da f7f1                      brne    pp_FETs_off_wt
0002db 7f8e                      cbr     flags1, (1<<POWER_OFF)  ; enable power
0002dc e00a                      ldi     temp1, PWR_STARTUP      ; set limiter
0002dd 2ed0                      mov     sys_control, temp1
0002de 930f
0002df e002
0002e0 9500
0002e1 de78
0002e2 910f                      SetPWMi(PWR_STARTUP*1/4);
0002e3 d174                      rcall   com5com6
0002e4 d17a                      rcall   com6com1
0002e5 dfe7                      rcall   wait64ms
0002e6 dfe6                      rcall   wait64ms
0002e7 930f
0002e8 e005
0002e9 9500
0002ea de6f
0002eb 910f                      SetPWMi(PWR_STARTUP*2/4);
0002ec dfe0                      rcall   wait64ms
0002ed 930f
0002ee e007
0002ef 9500
0002f0 de69
0002f1 910f                      SetPWMi(PWR_STARTUP*3/4);
0002f2 dfda                      rcall   wait64ms
0002f3 930f
0002f4 e00a
0002f5 9500
0002f6 de63
0002f7 910f                      SetPWMi(PWR_STARTUP);               
0002f8 9508                      ret                
                 ;-----bko-----------------------------------------------------------------
                 ; **** startup loop ****
0002f9 dfb7      init_startup:   rcall   switch_power_off
0002fa dfd1                      rcall   motor_brake
                 wait_for_power_on:
0002fb 9ac5                      DbgLEDOn
                 
0002fc de36                      rcall   evaluate_rc_puls
0002fd 30f7                      cpi     ZH, MIN_DUTY + 1
0002fe f3e0                      brcs    wait_for_power_on
                                 AcInit
0002ff dfd2                      rcall   pre_align
                 
000300 9ac5                      DbgLEDOn
                 
000301 7f9b                      cbr     flags2, (1<<SCAN_TIMEOUT)
000302 e000                      ldi     temp1, 0
000303 9300 007c                 sts     goodies, temp1
000305 e208                      ldi     temp1, 40*CLK_SCALE; x 32msec
000306 2ee0                      mov     t1_timeout, temp1
000307 dece                      rcall   set_all_timings
000308 df98                      rcall   start_timeout
                 ;-----bko-----------------------------------------------------------------
                 ; **** start control loop ****
                 
                 ; state 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
000309 ff94      start1:         sbrs    flags2, COMP_SAVE       ; high ?
00030a c010                      rjmp    start1_2                ; .. no - loop, while high
                 
00030b fd70      start1_0:       sbrc    flags0, OCT1_PENDING
00030c c002                      rjmp    start1_1
00030d 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
00030e c013                      rjmp    start1_9
00030f dfb7      start1_1:       rcall   sync_with_poweron
                 
000310 fd94                      sbrc    flags2, COMP_SAVE       ; high ?
000311 cff9                      rjmp    start1_0                ; .. no - loop, while high
                 
                 ; do the special 120- switch
000312 e000                      ldi     temp1, 0
000313 9300 007c                 sts     goodies, temp1
000315 d107                      rcall   com1com2
000316 d110                      rcall   com2com3
000317 d121                      rcall   com3com4
000318 de1a                      rcall   evaluate_rc_puls
000319 df87                      rcall   start_timeout
00031a c031                      rjmp    start4
                         
00031b fd70      start1_2:       sbrc    flags0, OCT1_PENDING
00031c c002                      rjmp    start1_3
00031d 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
00031e c003                      rjmp    start1_9
00031f dfa7      start1_3:       rcall   sync_with_poweron
000320 ff94                      sbrs    flags2, COMP_SAVE       ; high ?
000321 cff9                      rjmp    start1_2                ; .. no - loop, while low
                 
                 start1_9:
000322 d0fa                      rcall   com1com2
000323 df7d                      rcall   start_timeout
                 
                 ; state 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
                 
000324 fd94      start2:         sbrc    flags2, COMP_SAVE
000325 c008                      rjmp    start2_2
                 
000326 fd70      start2_0:       sbrc    flags0, OCT1_PENDING
000327 c002                      rjmp    start2_1
000328 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000329 c00b                      rjmp    start2_9
00032a df9c      start2_1:       rcall   sync_with_poweron
00032b ff94                      sbrs    flags2, COMP_SAVE
00032c cff9                      rjmp    start2_0
00032d c007                      rjmp    start2_9
                 
00032e fd70      start2_2:       sbrc    flags0, OCT1_PENDING
00032f c002                      rjmp    start2_3
000330 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000331 c003                      rjmp    start2_9
000332 df94      start2_3:       rcall   sync_with_poweron
000333 fd94                      sbrc    flags2, COMP_SAVE
000334 cff9                      rjmp    start2_2
                 
                 start2_9:
000335 d0f1                      rcall   com2com3
000336 ddfc                      rcall   evaluate_rc_puls
000337 df69                      rcall   start_timeout
                 
                 ; state 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 
000338 ff94      start3:         sbrs    flags2, COMP_SAVE
000339 c008                      rjmp    start3_2
                 
00033a fd70      start3_0:       sbrc    flags0, OCT1_PENDING
00033b c002                      rjmp    start3_1
00033c 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
00033d c00b                      rjmp    start3_9
00033e df88      start3_1:       rcall   sync_with_poweron
00033f fd94                      sbrc    flags2, COMP_SAVE
000340 cff9                      rjmp    start3_0
000341 c007                      rjmp    start3_9
                 
000342 fd70      start3_2:       sbrc    flags0, OCT1_PENDING
000343 c002                      rjmp    start3_3
000344 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000345 c003                      rjmp    start3_9
000346 df80      start3_3:       rcall   sync_with_poweron
000347 ff94                      sbrs    flags2, COMP_SAVE
000348 cff9                      rjmp    start3_2
                 
                 start3_9:
000349 d0ef                      rcall   com3com4
00034a de22                      rcall   set_new_duty
00034b df55                      rcall   start_timeout
                 
                 ; state 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
                 
00034c fd94      start4:         sbrc    flags2, COMP_SAVE
00034d c008                      rjmp    start4_2
                 
00034e fd70      start4_0:       sbrc    flags0, OCT1_PENDING
00034f c002                      rjmp    start4_1
000350 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000351 c00b                      rjmp    start4_9
000352 df74      start4_1:       rcall   sync_with_poweron
000353 ff94                      sbrs    flags2, COMP_SAVE
000354 cff9                      rjmp    start4_0
000355 c007                      rjmp    start4_9
                 
000356 fd70      start4_2:       sbrc    flags0, OCT1_PENDING
000357 c002                      rjmp    start4_3
000358 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000359 c003                      rjmp    start4_9
00035a df6c      start4_3:       rcall   sync_with_poweron
00035b fd94                      sbrc    flags2, COMP_SAVE
00035c cff9                      rjmp    start4_2
                 
                 start4_9:
00035d d0e5                      rcall   com4com5
00035e df42                      rcall   start_timeout
                 
                 
                 ; state 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
                 
                 
00035f ff94      start5:         sbrs    flags2, COMP_SAVE
000360 c008                      rjmp    start5_2
                 
000361 fd70      start5_0:       sbrc    flags0, OCT1_PENDING
000362 c002                      rjmp    start5_1
000363 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000364 c00b                      rjmp    start5_9
000365 df61      start5_1:       rcall   sync_with_poweron
000366 fd94                      sbrc    flags2, COMP_SAVE
000367 cff9                      rjmp    start5_0
000368 c007                      rjmp    start5_9
                 
000369 fd70      start5_2:       sbrc    flags0, OCT1_PENDING
00036a c002                      rjmp    start5_3
00036b 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
00036c c003                      rjmp    start5_9
00036d df59      start5_3:       rcall   sync_with_poweron
00036e ff94                      sbrs    flags2, COMP_SAVE
00036f cff9                      rjmp    start5_2
                 
                 start5_9:
000370 d0e7                      rcall   com5com6
000371 ddd8                      rcall   evaluate_sys_state
000372 df2e                      rcall   start_timeout
                 
                 ; state 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
                 
000373 fd94      start6:         sbrc    flags2, COMP_SAVE
000374 c008                      rjmp    start6_2
                 
000375 fd70      start6_0:       sbrc    flags0, OCT1_PENDING
000376 c002                      rjmp    start6_1
000377 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000378 c00b                      rjmp    start6_9
000379 df4d      start6_1:       rcall   sync_with_poweron
00037a ff94                      sbrs    flags2, COMP_SAVE
00037b cff9                      rjmp    start6_0
00037c c007                      rjmp    start6_9
                 
00037d fd70      start6_2:       sbrc    flags0, OCT1_PENDING
00037e c002                      rjmp    start6_3
00037f 6094                      sbr     flags2, (1<<SCAN_TIMEOUT)
000380 c003                      rjmp    start6_9
000381 df45      start6_3:       rcall   sync_with_poweron
000382 fd94                      sbrc    flags2, COMP_SAVE
000383 cff9                      rjmp    start6_2
                 
                 start6_9:
000384 d0da                      rcall   com6com1
                 
000385 2d02                      mov     temp1, tcnt0_power_on
000386 3f0a                      cpi     temp1, NO_POWER
000387 f409                      brne    s6_power_ok
000388 cf70                      rjmp    init_startup
                 
000389 20ee      s6_power_ok:    tst     t1_timeout
00038a f409                      brne    s6_test_rpm
00038b cf6d                      rjmp    init_startup            ;-) demich
                                 
00038c 9100 0066 s6_test_rpm:    lds     temp1, timing_x
00038e 2300                      tst     temp1
00038f f421                      brne    s6_goodies
000390 9100 0065                 lds     temp1, timing_h         ; get actual RPM reference high
                 ;               cpi     temp1, PWR_RANGE1*CLK_SCALE
000392 3200                      cpi     temp1, PWR_RANGE2*CLK_SCALE
000393 f050                      brcs    s6_run1
                 
000394 9100 007c s6_goodies:     lds     temp1, goodies
000396 fd92                      sbrc    flags2, SCAN_TIMEOUT
000397 2700                      clr     temp1
000398 9503                      inc     temp1
000399 9300 007c                 sts     goodies,  temp1
00039b 7f9b                      cbr     flags2, (1<<SCAN_TIMEOUT)
00039c 330c                      cpi     temp1, ENOUGH_GOODIES
00039d f038                      brcs    s6_start1       
                 
00039e ef0f      s6_run1:        ldi     temp1, 0xff
00039f 2ef0                      mov     run_control, temp1
                 
0003a0 decc                      rcall   calc_next_timing
0003a1 ded3                      rcall   set_OCT1_tot
                 
0003a2 98c5                      DbgLEDOff
                 
0003a3 7d9f                      cbr     flags2, (1<<STARTUP)
0003a4 c002                      rjmp    run1                    ; running state begins
                 
0003a5 defb      s6_start1:      rcall   start_timeout           ; need to be here for a correct temp1=comp_state
0003a6 cf62                      rjmp    start1                  ; go back to state 1
                 
                 ;-----bko-----------------------------------------------------------------
                 ; **** running control loop ****
                 
                 ; run 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
                 
0003a7 d057      run1:           rcall   wait_for_low
0003a8 ff70                      sbrs    flags0, OCT1_PENDING
0003a9 c041                      rjmp    run_to_start
0003aa d063                      rcall   wait_for_high
0003ab ff70                      sbrs    flags0, OCT1_PENDING
0003ac c03e                      rjmp    run_to_start
0003ad 6480                      sbr     flags1, (1<<EVAL_RPM)
0003ae ded7                      rcall   wait_OCT1_before_switch
0003af d06d                      rcall   com1com2
0003b0 debc                      rcall   calc_next_timing
0003b1 dec1                      rcall   wait_OCT1_tot
                                 
                 ; run 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
                 
0003b2 d05b      run2:           rcall   wait_for_high
0003b3 ff70                      sbrs    flags0, OCT1_PENDING
0003b4 c036                      rjmp    run_to_start
0003b5 d049                      rcall   wait_for_low
0003b6 ff70                      sbrs    flags0, OCT1_PENDING
0003b7 c033                      rjmp    run_to_start
0003b8 6180                      sbr     flags1, (1<<EVAL_RC_PULS)
0003b9 decc                      rcall   wait_OCT1_before_switch
0003ba d06c                      rcall   com2com3
0003bb deb1                      rcall   calc_next_timing
0003bc deb6                      rcall   wait_OCT1_tot
                 
                 ; run 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 
0003bd d041      run3:           rcall   wait_for_low
0003be ff70                      sbrs    flags0, OCT1_PENDING
0003bf c02b                      rjmp    run_to_start
0003c0 d04d                      rcall   wait_for_high
0003c1 ff70                      sbrs    flags0, OCT1_PENDING
0003c2 c028                      rjmp    run_to_start
0003c3 6880                      sbr     flags1, (1<<EVAL_PWM)
0003c4 dec1                      rcall   wait_OCT1_before_switch
0003c5 d073                      rcall   com3com4
0003c6 dea6                      rcall   calc_next_timing
0003c7 deab                      rcall   wait_OCT1_tot
                 
                 ; run 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
0003c8 d045      run4:           rcall   wait_for_high
0003c9 ff70                      sbrs    flags0, OCT1_PENDING
0003ca c020                      rjmp    run_to_start
0003cb d033                      rcall   wait_for_low
0003cc ff70                      sbrs    flags0, OCT1_PENDING
0003cd c01d                      rjmp    run_to_start
0003ce deb7                      rcall   wait_OCT1_before_switch
0003cf d073                      rcall   com4com5
0003d0 de9c                      rcall   calc_next_timing
0003d1 dea1                      rcall   wait_OCT1_tot
                 
                 ; run 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
                 
0003d2 d02c      run5:           rcall   wait_for_low
0003d3 ff70                      sbrs    flags0, OCT1_PENDING
0003d4 c016                      rjmp    run_to_start
0003d5 d038                      rcall   wait_for_high
0003d6 ff70                      sbrs    flags0, OCT1_PENDING
0003d7 c013                      rjmp    run_to_start
0003d8 6280                      sbr     flags1, (1<<EVAL_SYS_STATE)
0003d9 deac                      rcall   wait_OCT1_before_switch
0003da d07d                      rcall   com5com6
0003db de91                      rcall   calc_next_timing
0003dc de96                      rcall   wait_OCT1_tot
                 
                 ; run 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
                 
0003dd d030      run6:           rcall   wait_for_high
0003de ff70                      sbrs    flags0, OCT1_PENDING
0003df c00b                      rjmp    run_to_start
0003e0 d01e                      rcall   wait_for_low
0003e1 ff70                      sbrs    flags0, OCT1_PENDING
0003e2 c008                      rjmp    run_to_start
0003e3 dea2                      rcall   wait_OCT1_before_switch
0003e4 d07a                      rcall   com6com1
0003e5 de87                      rcall   calc_next_timing
0003e6 de8c                      rcall   wait_OCT1_tot
                 
                 ;               rjmp    run6_2
                 
0003e7 9100 0066                 lds     temp1, timing_x
0003e9 2300                      tst     temp1
0003ea f029                      breq    run6_2                  ; higher than 610 RPM if zero
                 .if CLK_SCALE==2                                
                 .endif                
0003eb 6290      run_to_start:   sbr     flags2, (1<<STARTUP)
0003ec 7f97                      cbr     flags2, (1<<POFF_CYCLE)
0003ed ff80                      sbrs    flags1, POWER_OFF
0003ee c00d                      rjmp    restart_control
0003ef cf0b                      rjmp    wait_for_power_on
                 
0003f0 7f97      run6_2:         cbr     flags2, (1<<POFF_CYCLE)
0003f1 20ff                      tst     run_control             ; only once !
0003f2 f041                      breq    run6_9
0003f3 94fa                      dec     run_control
0003f4 f029                      breq    run6_3                  ; poweroff if 0
0003f5 2d0f                      mov     temp1, run_control
0003f6 3001                      cpi     temp1, 1                ; poweroff if 1
0003f7 f011                      breq    run6_3
0003f8 3002                      cpi     temp1, 2                ; poweroff if 2
0003f9 f409                      brne    run6_9
0003fa 6098      run6_3:         sbr     flags2, (1<<POFF_CYCLE)
                 
                 run6_9:
0003fb cfab                      rjmp    run1                    ; go back to run 1
                 
                 restart_control:
0003fc 94f8                      cli                             ; disable all interrupts
0003fd deb3                      rcall   switch_power_off
0003fe cc1e                      rjmp    reset
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; *** scan comparator utilities ***
                 .macro __wait_for_filter
                                 clc
                                 sbis    ACSR, ACO
                                 sec
                                 brcc    wait_for_filter_1
                                 inc     temp2
                 wait_for_filter_1:
                                 rol     temp1
                                 brcc    wait_for_filter_2
                                 dec     temp2
                 wait_for_filter_2:
                 .endmacro
                                                 
                 wait_for_low:   
0003ff ef0f                      ldi     temp1, 0xFF
000400 e018                      ldi     temp2, 8
                 wait_for_low_loop:
000401 ff70                      sbrs    flags0, OCT1_PENDING
000402 9508                      ret
000403 9488
000404 9b45
000405 9408
000406 f408
000407 9513
000408 1f00
000409 f408
00040a 951a                      __wait_for_filter
00040b 3012                      cpi     temp2, (8-7) + 1
00040c f7a0                      brcc    wait_for_low_loop
00040d 9508                      ret
                                                
                 wait_for_high:   
00040e e000                      ldi     temp1, 0x0
00040f e010                      ldi     temp2, 0
                 wait_for_high_loop:
000410 ff70                      sbrs    flags0, OCT1_PENDING
000411 9508                      ret
000412 9488
000413 9b45
000414 9408
000415 f408
000416 9513
000417 1f00
000418 f408
000419 951a                      __wait_for_filter
00041a 3017                      cpi     temp2, 7
00041b f3a0                      brcs    wait_for_high_loop
00041c 9508                      ret
                 ;-----bko-----------------------------------------------------------------
                 ; *** commutation utilities ***
00041d 9894      com1com2:       BpFET_off                             ; Bp off
00041e ff80                      sbrs    flags1, POWER_OFF
00041f 9a95                      ApFET_on                              ; Ap on
000420 e004
000421 b907
000422 9837
000423 b700
000424 6008
000425 bf00                      AcPhaseB
000426 9508                      ret
                 
000427 e104      com2com3:       ldi     temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
000428 bf09                      out     TIMSK, temp1                  ;  .. only ONE should change these values at the time
000429 0000                      nop
00042a 7d7f                      cbr     flags0, (1<<A_FET)            ; next nFET = BnFET
00042b 7e7f                      cbr     flags0, (1<<C_FET)
00042c fd81                      sbrc    flags1, FULL_POWER
00042d c002                      rjmp    c2_switch
00042e fd76                      sbrc    flags0, I_OFF_CYCLE           ; was power off ?
00042f c003                      rjmp    c2_done                       ; .. yes - futhermore work is done in timer0 interrupt
000430 98c0      c2_switch:      CnFET_off                             ; Cn off
000431 ff80                      sbrs    flags1, POWER_OFF
000432 9ac1                      BnFET_on                              ; Bn on
000433 e105      c2_done:        ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
000434 bf09                      out     TIMSK, temp1
000435 7f07
000436 bf00
000437 9a37                      AcPhaseC
000438 9508                      ret
                 
000439 9895      com3com4:       ApFET_off                             ; Ap off
00043a ff80                      sbrs    flags1, POWER_OFF
00043b 9a93                      CpFET_on                              ; Cp on
00043c e005
00043d b907
00043e 9837
00043f b700
000440 6008
000441 bf00                      AcPhaseA
000442 9508                      ret
                 
000443 e104      com4com5:       ldi     temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
000444 bf09                      out     TIMSK, temp1                  ;  .. only ONE should change these values at the time
000445 0000                      nop
000446 6270                      sbr     flags0, (1<<A_FET)            ; next nFET = AnFET
000447 7e7f                      cbr     flags0, (1<<C_FET)
000448 fd81                      sbrc    flags1, FULL_POWER
000449 c002                      rjmp    c4_switch
00044a fd76                      sbrc    flags0, I_OFF_CYCLE           ; was power off ?
00044b c003                      rjmp    c4_done                       ; .. yes - futhermore work is done in timer0 interrupt
00044c 98c1      c4_switch:      BnFET_off                             ; Bn off
00044d ff80                      sbrs    flags1, POWER_OFF
00044e 9ac2                      AnFET_on                              ; An on
00044f e105      c4_done:        ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
000450 bf09                      out     TIMSK, temp1
000451 e004
000452 b907
000453 9837
000454 b700
000455 6008
000456 bf00                      AcPhaseB
000457 9508                      ret
                 
000458 9893      com5com6:       CpFET_off                             ; Cp off
000459 ff80                      sbrs    flags1, POWER_OFF
00045a 9a94                      BpFET_on                              ; Bp on
00045b 7f07
00045c bf00
00045d 9a37                      AcPhaseC
00045e 9508                      ret
                 
00045f e104      com6com1:       ldi     temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
000460 bf09                      out     TIMSK, temp1                  ;  .. only ONE should change these values at the time
000461 0000                      nop
000462 7d7f                      cbr     flags0, (1<<A_FET)            ; next nFET = CnFET
000463 6170                      sbr     flags0, (1<<C_FET)
000464 fd81                      sbrc    flags1, FULL_POWER
000465 c002                      rjmp    c6_switch
000466 fd76                      sbrc    flags0, I_OFF_CYCLE           ; was power off ?
000467 c003                      rjmp    c6_done                       ; .. yes - futhermore work is done in timer0 interrupt
000468 98c2      c6_switch:      AnFET_off                             ; An off
000469 ff80                      sbrs    flags1, POWER_OFF
00046a 9ac0                      CnFET_on                              ; Cn on
00046b e105      c6_done:        ldi     temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
00046c bf09                      out     TIMSK, temp1
00046d e005
00046e b907
00046f 9837
000470 b700
000471 6008
000472 bf00                      AcPhaseA
000473 9508                      ret
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega8 register use summary:
r0 :   0 r1 :   9 r2 :   4 r3 :   0 r4 :   0 r5 :   0 r6 :   3 r7 :   2 
r8 :   2 r9 :   0 r10:   0 r11:   6 r12:   5 r13:   6 r14:   6 r15:   4 
r16: 242 r17:  65 r18:  54 r19:  48 r20:  26 r21:  11 r22:  12 r23:  53 
r24:  37 r25:  54 r26:   2 r27:   1 r28:  11 r29:  15 r30:  17 r31:   5 
x  :   1 y  :   0 z  :   0 
Registers used: 27 out of 35 (77.1%)

ATmega8 instruction use summary:
adc   :   9 add   :   6 adiw  :   0 and   :   0 andi  :   1 asr   :   0 
bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 brcc  :  11 brcs  :  12 
breq  :  12 brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 
brlo  :   4 brlt  :   0 brmi  :   0 brne  :  22 brpl  :   0 brsh  :   4 
brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 bst   :   0 
cbi   :  16 cbr   :  29 clc   :   2 clh   :   0 cli   :   4 cln   :   0 
clr   :  13 cls   :   0 clt   :   0 clv   :   0 clz   :   0 com   :   8 
cp    :   6 cpc   :   4 cpi   :  29 cpse  :   0 dec   :  16 eor   :   0 
fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :  21 
inc   :   7 ld    :   0 ldd   :   0 ldi   : 106 lds   :  44 lpm   :   0 
lsl   :   0 lsr   :  10 mov   :  27 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   8 or    :   0 ori   :   0 out   :  70 
pop   :   6 push  :   6 rcall : 116 ret   :  32 reti  :  19 rjmp  : 114 
rol   :   2 ror   :  18 sbc   :   5 sbci  :   4 sbi   :  16 sbic  :   2 
sbis  :   3 sbiw  :   0 sbr   :  41 sbrc  :  39 sbrs  :  39 sec   :   2 
seh   :   0 sei   :   3 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   1 std   :   0 
sts   :  47 sub   :   6 subi  :   4 swap  :   0 tst   :  13 wdr   :   0 

Instructions used: 50 out of 108 (46.3%)

ATmega8 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0008e8   2260     20   2280    8192  27.8%
[.dseg] 0x000060 0x0000e3      0    131    131    1024  12.8%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
